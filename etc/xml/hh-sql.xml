<?xml version="1.0" encoding="utf-8"?>
<sqls>
	<sql>

		<!--数据库集合 -->
		<database>
			<prop_coll>
				<column name="id" title="OID" />
				<column name="datname" title="数据库名称" />
				<column name="usename" title="所属者 " />
				<column name="spcname" title="所属表空间  " />
				<column name="description" title="注解  " />
				<sql>
					SELECT hh_database.oid as id,
					datname,usename,spcname,descr.description
					FROM
					hh_database  LEFT OUTER JOIN hh_shdescription descr ON(hh_database.oid=descr.objoid AND descr.classoid='hh_database'::regclass),hh_user u,hh_tablespace t 
					WHERE
					datdba=u.usesysid
					AND
					dattablespace=t.oid
					and datname not in('template0','template1')
				</sql>
			</prop_coll>

			<stat_coll>
				<column name="datname" title="数据库名称" />
				<column name="numbackends" title="后台进程数" />
				
				<column name="xact_commit" title="Xct已提交 " />
				<column name="xact_rollback" title="Xct已回滚 " />
				
				<column name="blks_read" title="块读取 " />
				<column name="blks_hit" title="块命中 " />

				<column name="tup_returned" title="已返回元组" />
				<column name="tup_fetched" title="已提取元组" />
				<column name="tup_inserted" title="已插入元组" />
				<column name="tup_updated" title="已更新元组" />
				<column name="tup_deleted" title="已删除元组" />
				
				<column name="conflicts" title="冲突" />
				<column name="temp_files" title="临时文件" />
				<column name="temp_bytes" title="临时字节 " />
				<column name="deadlocks" title="死锁 " />
				<column name="stats_reset" title="最后统计重置  " />
			
				<sql>SELECT * FROM hh_stat_database</sql>
			</stat_coll>
			<!--数据库实例 -->
			<prop>
				<column name="datname" title="数据库名称" />
				<column name="usename" title="所有者" />
				<column name="size" title="数据库大小" />
				<column name="spcname" title="所属表空间" />
				<column name="datconnlimit" title="连接数限制" />
				<column name="datcollate" title="字符排序" />
				<column name="datctype" title="字符分类" />
				
				<sql>
					SELECT
					*,hh_size_pretty(hh_database_size(hh_database.datname))
					AS size
					FROM
					hh_database,hh_user u,hh_tablespace t
					WHERE
					datdba=u.usesysid
					AND
					dattablespace=t.oid
					AND datname=?
				</sql>
			</prop>

			<stat>
				<column name="datname" title="数据库名称" />
				<column name="numbackends" title="后台进程数" />
				
				<column name="xact_commit" title="Xct已提交 " />
				<column name="xact_rollback" title="Xct已回滚 " />
				
				<column name="blks_read" title="块读取 " />
				<column name="blks_hit" title="块命中 " />

				<column name="tup_returned" title="已返回元组" />
				<column name="tup_fetched" title="已提取元组" />
				<column name="tup_inserted" title="已插入元组" />
				<column name="tup_updated" title="已更新元组" />
				<column name="tup_deleted" title="已删除元组" />
				
				<column name="conflicts" title="冲突" />
				<column name="temp_files" title="临时文件" />
				<column name="temp_bytes" title="临时字节 " />
				<column name="deadlocks" title="死锁 " />
				<column name="stats_reset" title="最后统计重置  " />
				<sql>
					SELECT * from hh_stat_database
					WHERE datname=?
				</sql>
			</stat>
			
			
			<create>
				<column name="dbName" title="数据库名称  " />
				<column name="usename" title="所有者  " />
				<column name="datconnlimit" title="连接数限制  " />
				<sql>
				CREATE DATABASE ?
  					WITH ENCODING='UTF8'
       				OWNER=?
       				CONNECTION LIMIT=?;
				</sql>
			</create>
			
			<drop>
				<column name="dbName" title="数据库名称  " />
				<sql>
				DROP DATABASE ?
				</sql>
			</drop>
			
		</database>

		<!--表空间集合 -->

		<tablespace>
			<prop_coll> 
				<column name="spcname" title="表空间" />
				<column name="usename" title="所有者" /> 
				<column name="size" title="大小" />
				<column name="tbs_local" title="位置" /> 
				<column name="description" title="注解  " />
				<sql>
					SELECT u.usename,
					hh_catalog.shobj_description(oid, 'hh_tablespace') AS description,
					hh_tablespace.spcname,
					hh_size_pretty(hh_tablespace_size(hh_tablespace.spcname)) AS size,
					hh_tablespace_location(oid) tbs_local
					FROM hh_tablespace ,hh_user u
		WHERE spcowner=u.usesysid
				</sql>
			</prop_coll>
			
			<!--表空间实例 -->
			<prop>
				<column name="spcname" title="表空间" />
				<column name="usename" title="所有者" /> 
				<column name="size" title="大小" />
				<column name="description" title="注解  " />
				<sql>
					SELECT u.usename,
					hh_catalog.shobj_description(oid, 'hh_tablespace') AS description,
					hh_tablespace.spcname,
					hh_size_pretty(hh_tablespace_size(hh_tablespace.spcname)) AS size,
					hh_tablespace_location(oid) tbs_local
					FROM hh_tablespace ,hh_user u
					WHERE spcowner=u.usesysid and hh_tablespace.spcname=?
				</sql>
			</prop>

			<stat>
			</stat>
		</tablespace>
 		<types> <!-- 数据类型 -->
			<prop> 
				<sql>
					SELECT tn, CASE WHEN typmodIN = 0 THEN FALSE ELSE TRUE END AS has_length,   (
					SELECT count(*)     
					  FROM hh_ATTRIBUTE a, hh_CLASS c, hh_namespace n    
					 WHERE a.atttypid = ts.oid     
					   AND a.attnum > 0     
					   AND a.attrelid = c.oid 			     
					   AND c.relnamespace = n.oid     
					   AND n.nspNAME NOT IN ('hh_catalog', 'information_schema')) AS usage_count 
					  FROM (
					SELECT typNAME AS tn, typrelid, typelem, typtype,  typcategory, typbasetype, typmodin, oid    
					  FROM hh_TYPE    UNION   
					SELECT format_type(oid, null) AS tn,typrelid, typelem, typtype, typcategory, typbasetype, typmodin, oid    
					  FROM hh_type) AS ts 
					 WHERE typrelid = 0 
					   AND typelem = 0 
					   AND typTYPE != 'p' 
					   AND typcategory != 'X' 
					   AND typbasetype = 0  UNION 
					SELECT 'serial', false, 0  UNION 
					SELECT 'bigserial', false, 0 
					 ORDER BY 1
				</sql>
			</prop>
		</types>
		<role> <!-- 用户角色 -->
			<prop_coll> 
				<column name="rolname" title="角色名称" /> 
				<column name="description" title="注解" /> 
				<sql>
					SELECT tab.oid, tab.*, hh_catalog.shobj_description(tab.oid, 'hh_authid') AS description,
	(SELECT array_agg(label) FROM hh_shseclabel sl1 WHERE sl1.objoid=tab.oid) AS labels,
	(SELECT array_agg(provider) FROM hh_shseclabel sl2 WHERE sl2.objoid=tab.oid) AS providers FROM hh_authid tab WHERE NOT rolcanlogin ORDER BY rolname
				</sql>
			</prop_coll>
		</role>
		<!--用户集合 -->
		<user>
			<!--登陆用户集合属性 -->
			<prop_coll>
				<column name="id" title="OID" /> 
				<column name="rolname" title="用户名称" /> 
				<column name="description" title="注解" /> 
				<sql> 
					SELECT tab.oid as id, tab.*, hh_catalog.shobj_description(tab.oid, 'hh_authid') AS description,
	(SELECT array_agg(label) FROM hh_shseclabel sl1 WHERE sl1.objoid=tab.oid) AS labels,
	(SELECT array_agg(provider) FROM hh_shseclabel sl2 WHERE sl2.objoid=tab.oid) AS providers FROM hh_authid tab WHERE rolcanlogin ORDER BY rolname					
				</sql>
			</prop_coll>
			
			<prop>
				<column name="rolname" title="用户名称" /> 
				<column name="rolsuper" title="超级用户" /> 
				<column name="rolcreaterole" title="创建角色" /> 
				<column name="rolcreatedb" title="创建数据库" /> 
				<column name="rolcanlogin" title="可以登录" /> 
				<sql> 
				SELECT rolname, rolsuper, rolinherit, rolcreaterole, rolcreatedb,  
				rolcanlogin, oid FROM hh_roles where oid=?
				</sql>
			</prop>
		</user>

		<!--模式 -->
		<schema>
			<!--模式集合属性 -->
			<prop_coll>
				<column name="name" title="模式名称" />
				<column name="usename" title="所有者" />
				<sql>
					SELECT nspname as name,
					oid as id,
					usename
					FROM hh_namespace,hh_user u
					WHERE nspowner=u.usesysid
					AND nspname NOT
					IN
					('information_schema', 'hh_catalog','hh_toast')
					AND nspname NOT LIKE E'hh\\_temp\\_%'AND nspname NOT LIKE E'hh\\_toast_temp\\_%'
					ORDER BY nspname
				</sql>
			</prop_coll>
			<prop>
				<column name="nspname" title="模式名称" />
				<column name="namespaceowner" title="创建者" />
				<column name="nspacl" title="所有者" />
				<column name="oid" title="oid" /> 
				<column name="description" title="注解" />
				<sql>
					SELECT CASE WHEN nspname LIKE E'hh\\_temp\\_%' THEN 1
	            WHEN (nspname LIKE E'hh\\_%') THEN 0
	            ELSE 3 END AS nsptyp,
	       nsp.nspname, nsp.oid, hh_get_userbyid(nspowner) AS namespaceowner, nspacl, description,       has_schema_privilege(nsp.oid, 'CREATE') as cancreate,
	(SELECT array_agg(label) FROM hh_seclabels sl1 WHERE sl1.objoid=nsp.oid) AS labels,
	(SELECT array_agg(provider) FROM hh_seclabels sl2 WHERE sl2.objoid=nsp.oid) AS providers
	  FROM hh_namespace nsp
	  LEFT OUTER JOIN hh_description des ON (des.objoid=nsp.oid AND des.classoid='hh_namespace'::regclass)
	 WHERE nsp.oid=?::oid
	   AND NOT ((nspname = 'hh_catalog' AND EXISTS (SELECT 1 FROM hh_class WHERE relname = 'hh_class' AND relnamespace = nsp.oid LIMIT 1)) OR
	(nspname = 'hhagent' AND EXISTS (SELECT 1 FROM hh_class WHERE relname = 'hha_job' AND relnamespace = nsp.oid LIMIT 1)) OR
	(nspname = 'information_schema' AND EXISTS (SELECT 1 FROM hh_class WHERE relname = 'tables' AND relnamespace = nsp.oid LIMIT 1)) OR
	(nspname LIKE '_%' AND EXISTS (SELECT 1 FROM hh_proc WHERE proname='slonyversion' AND pronamespace = nsp.oid LIMIT 1))
	)  AND nspname NOT LIKE E'hh\\_temp\\_%'AND nspname NOT LIKE E'hh\\_toast_temp\\_%' ORDER BY 1, nspname
				</sql>
			</prop>
		</schema>
		
		<table>
			<prop_coll>
				<column name="id" title="oid" />
				<column name="name" title="数据表" /> 
				<column name="relowner" title="所有者" /> 
				<column name="comment" title="注解" /> 
				<!-- 需要传入参数 namespace --> 
				<sql> 
					SELECT c.relname AS name,'R' AS table_type,   d.description AS comment,  c.oid AS id , hh_get_userbyid(c.relowner) AS relowner FROM hh_class c 
	LEFT JOIN hh_description d  ON c.oid = d.objoid  AND d.objsubid = 0 , hh_namespace nsp  WHERE nsp.nspname=?	 and c.relnamespace = nsp.oid	
	AND c.relkind = 'r' ORDER BY c.relname 
				</sql>
			</prop_coll>
			<prop>
				<column name="relname" title="表名称" /> 
				<!-- <column name="spcname" title="表空间" />  -->
				<column name="oid" title="oid" />
				<column name="relowner" title="创建者" />
				<column name="relacl" title="所有者" />
				<column name="conkey" title="主键" />
				<column name="description" title="注解" />  
				<sql>
	SELECT rel.oid, rel.relname, rel.reltablespace AS spcoid, spc.spcname, hh_get_userbyid(rel.relowner) AS relowner, rel.relacl, rel.relhasoids, rel.relhassubclass, rel.reltuples, des.description, con.conname, con.conkey,
	        rel.relpersistence , spc.*
	   FROM hh_class rel
	  LEFT OUTER JOIN hh_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN hh_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='hh_class'::regclass)
	  LEFT OUTER JOIN hh_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN hh_class tst ON tst.oid = rel.reltoastrelid
	 LEFT JOIN hh_type typ ON rel.reloftype=typ.oid
	 WHERE rel.relkind IN ('r','s','t') AND rel.relnamespace = ?::oid
	 and rel.relname=?
	 ORDER BY rel.relname
				</sql>
			</prop> 
			<columnspaykey>
				<sql>
					select hh_constraint.conname as pk_name,hh_attribute.attname as colname,hh_type.typname as typename,ss.ordinal_position from hh_constraint 
					inner join hh_class  on hh_constraint.conrelid = hh_class.oid  inner join hh_attribute on hh_attribute.attrelid = hh_class.oid  and  hh_attribute.attnum = any(hh_constraint.conkey) 
					inner join hh_type on hh_type.oid = hh_attribute.atttypid inner join hh_catalog.hh_namespace n on n.oid = hh_class.relnamespace
					inner join  (select * from information_schema.columns where table_schema='?' and table_name='?') ss on hh_attribute.attname=ss.column_name 
					where hh_class.relname = '?' and hh_constraint.contype='p' and n.nspname='?' 
				</sql>
			</columnspaykey> 		
			<columnsinfo>
				<sql>
					SELECT col.table_name, col.column_name 名称, COALESCE(col.character_maximum_length,  col.numeric_precision) 长度,
					case WHEN  is_nullable='NO' then true when is_nullable='YES' THEN FALSE end as 不是null,col.numeric_scale 小数点,col.datetime_precision, 
					col.ordinal_position as position, b.atttypmod, b.attndims, col.data_type AS col_type, et.typelem, et.typlen, et.typtype, b.atttypid, col.udt_schema,
					col.udt_name 类型, col.column_default AS col_default, col_description(c.oid, col.ordinal_position) AS comment, b.attacl, 
					coll.collname FROM information_schema.columns AS col LEFT JOIN hh_namespace ns ON ns.nspname = col.table_schema LEFT JOIN hh_class c ON col.table_name = c.relname
					AND c.relnamespace = ns.oid LEFT JOIN hh_attrdef a ON c.oid = a.adrelid AND col.ordinal_position = a.adnum LEFT JOIN hh_attribute b ON b.attrelid = c.oid AND b.attname = col.column_name
					LEFT JOIN hh_type et ON et.oid = b.atttypid LEFT JOIN hh_collation coll ON coll.oid = b.attcollation
					WHERE c.oid=? ORDER BY col.table_name, col.ordinal_position
				</sql>
			</columnsinfo> 		
			<columnsbyname>
				<sql>
						select column_name 名称,udt_name 类型,COALESCE(character_maximum_length ,numeric_precision) 长度,numeric_scale 小数点,case WHEN  is_nullable='NO' then true 
						 when is_nullable='YES' THEN FALSE end 不是null,ordinal_position as position from information_schema.columns 
						where table_schema='?' and table_name = '?'
				</sql>
			</columnsbyname> 	
			<!--  获取外键表字段 -->	
			<attname>
				<sql>
					select attname from hh_attribute where attrelid=? and attnum in (?)
				</sql>
			</attname> 		
			<!--  获取索引字段 -->	
			<indexdef>
				<sql>
					SELECT hh_get_indexdef (?, ?, TRUE)
				</sql>
			</indexdef> 		
		</table>
		<fittable>
			<prop_coll>
				<column name="column_name" title="名称" /> 
				<column name="udt_name" title="类型" /> 
				<column name="length" title="长度" /> 
				<column name="numeric_scale" title="小数点" /> 
				<column name="is_null" title="不是null" /> 
				<column name="parkey" title="主键" /> 
				<column name="position" title="position" /> 
				<!-- 需要传入参数 namespace --> 
				<sql> 
				select column_name,udt_name,COALESCE(character_maximum_length ,numeric_precision) length,numeric_scale,case WHEN  is_nullable='NO' then true
					when is_nullable='YES' THEN FALSE end is_null,ordinal_position as position,'' as parkey from information_schema.columns
					where table_schema=? and table_name = ?
				</sql>
			</prop_coll>
			<prop>
				<column name="pk_name" title="pk_name" /> 
				<column name="colname" title="colname" /> 
				<column name="typename" title="typename" />
				<column name="ordinal_position" title="ordinal_position" />
				<sql>
					select hh_constraint.conname as pk_name,hh_attribute.attname as colname,hh_type.typname as typename,ss.ordinal_position from hh_constraint
					inner join hh_class  on hh_constraint.conrelid = hh_class.oid  inner join hh_attribute on hh_attribute.attrelid = hh_class.oid  and  hh_attribute.attnum = any(hh_constraint.conkey) 
					inner join hh_type on hh_type.oid = hh_attribute.atttypid inner join hh_catalog.hh_namespace n on n.oid = hh_class.relnamespace 
					inner join  (select * from information_schema.columns where table_schema=? and table_name=?) ss on hh_attribute.attname=ss.column_name 
					where hh_class.relname = ? and hh_constraint.contype='p' and n.nspname=?;
				</sql>
			</prop> 
		</fittable>
		<view>
			<prop_coll>
				<column name="id" title="OID" /> 
				<column name="name" title="视图" /> 
				<column name="relowner" title="所有者" /> 
				<column name="comment" title="注解" /> 
				<!-- 需要传入参数 namespace --> 
				<sql> 
					SELECT c.relname AS name,'R' AS table_type,   d.description AS comment,   c.oid AS id , hh_get_userbyid(c.relowner) AS relowner FROM hh_class c 
	LEFT JOIN hh_description d  ON c.oid = d.objoid  AND d.objsubid = 0 , hh_namespace nsp  WHERE nsp.nspname=?	 and c.relnamespace = nsp.oid	
	AND c.relkind = 'v'::char ORDER BY name 
	
				</sql>
			</prop_coll>
			
			<prop>
				<column name="relname" title="视图名称" /> 
				<column name="ev_class" title="oid" /> 
				 <column name="nspname" title="模式" /> 
				<column name="definition" title="定义" />
				<column name="owner" title="所有者" />
				<column name="description" title="注解" />  
				<sql>
					SELECT rw.oid, rw.*, relname, CASE WHEN relkind = 'r' THEN TRUE ELSE FALSE END AS parentistable, nspname, description,
			       hh_get_ruledef(rw.oid, true) AS definition 
				,hh_get_userbyid(cl.relowner) as owner
			  FROM hh_rewrite rw
			  JOIN hh_class cl ON cl.oid=rw.ev_class
			  JOIN hh_namespace nsp ON nsp.oid=cl.relnamespace
			  LEFT OUTER JOIN hh_description des ON (des.objoid=rw.oid AND des.classoid='hh_rewrite'::regclass)
			 WHERE ev_class = ?
			 ORDER BY rw.rulename
				</sql>
			</prop>
			
		</view>
		
		
		
	    <!--表字段 -->
		<columns>
			<prop_coll>
			<column name="name" title="列名" /> 
			<column name="datatype" title="数据类型" /> 
			<column name="nullable" title="非空" /> 
			<column name="default_value" title="默认值" /> 
			<column name="primary_key" title="是否主键" />
			<column name="comment" title="注解" /> 
			<sql>
				SELECT a.attname AS name,				
				       hh_catalog.format_type (a.atttypid, a.atttypmod) AS datatype,			--数据类型
				       a.attnotnull AS NULLABLE,					--可空的
				       a.attnum AS id,			 -- ID
				  (SELECT SUBSTRING (hh_catalog.hh_get_expr (d.adbin, d.adrelid)
				                     FOR 128) AS default_value
				   FROM hh_catalog.hh_attrdef d
				   WHERE d.adrelid = a.attrelid
					AND d.adnum = a.attnum
					AND a.atthasdef) AS default_value,		 --默认值
				       EXISTS
				  (SELECT 1
				   FROM
				     (SELECT unnest(conkey) attnum
				      FROM hh_constraint
				      WHERE conrelid = a.attrelid
				        AND contype = 'p') c
				   WHERE c.attnum =a.attnum) AS primary_key,			--主键
				              FALSE AS distribution_key,			--外键
				              d.description AS COMMENT 		--注释
				FROM hh_attribute a
				LEFT OUTER JOIN hh_description d 
				ON (a.attrelid = d.objoid AND d.objsubid = a.attnum)
				WHERE a.attrelid =? 									--表ID
				AND a.attnum > 0
				AND NOT a.attisdropped
				ORDER BY a.attnum	
				</sql>			
			</prop_coll>
			
			<prop>
				<column name="attname" title="列名" /> 
				<column name="attnotnull" title="不能为空" /> 
				<column name="attrelid" title="oid" />
				<column name="typname" title="数据类型" />
				<column name="attlen" title="长度" />
				<column name="isfk" title="是否外键" />
				<column name="description" title="注解" />  
				<sql>
	SELECT att.*, def.*, hh_catalog.hh_get_expr(def.adbin, def.adrelid) AS defval, CASE WHEN att.attndims > 0 THEN 1 ELSE 0 END AS isarray, format_type(ty.oid,NULL) AS typname, format_type(ty.oid,att.atttypmod) AS displaytypname, tn.nspname as typnspname, et.typname as elemtypname,
	  ty.typstorage AS defaultstorage, cl.relname, na.nspname, att.attstattarget, description, cs.relname AS sername, ns.nspname AS serschema,
	  (SELECT count(1) FROM hh_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup, indkey,
	  coll.collname, nspc.nspname as collnspname,
	  attoptions,
	  EXISTS(SELECT 1 FROM  hh_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As isfk,
	(SELECT array_agg(label) FROM hh_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS labels,
	(SELECT array_agg(provider) FROM hh_seclabels sl2 WHERE sl2.objoid=att.attrelid AND sl2.objsubid=att.attnum) AS providers
	  FROM hh_attribute att
	  JOIN hh_type ty ON ty.oid=atttypid
	  JOIN hh_namespace tn ON tn.oid=ty.typnamespace
	  JOIN hh_class cl ON cl.oid=att.attrelid
	  JOIN hh_namespace na ON na.oid=cl.relnamespace
	  LEFT OUTER JOIN hh_type et ON et.oid=ty.typelem
	  LEFT OUTER JOIN hh_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN hh_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='hh_class'::regclass)
	  LEFT OUTER JOIN (hh_depend JOIN hh_class cs ON objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	  LEFT OUTER JOIN hh_namespace ns ON ns.oid=cs.relnamespace
	  LEFT OUTER JOIN hh_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN hh_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN hh_namespace nspc ON coll.collnamespace=nspc.oid
	 WHERE att.attrelid = ?::oid
	   AND att.attnum=?
	   AND att.attnum > 0
	   AND att.attisdropped IS FALSE
	 ORDER BY att.attnum
				</sql>
			</prop> 
		</columns>
		<!--数据表的索引查询-->
		<indexs>
			<prop_coll>
				<column name="idxname" title="名称" /> 
				<column name="id" title="索引OID" />
				<column name="tabname" title="所属表" />
				<column name="amname" title="访问方式" />
				<column name="description" title="注解" />
				<column name="indexdef" title="定义"></column>
				<sql>
				SELECT DISTINCT ON(cls.relname) cls.oid as id, cls.relname as idxname, indrelid, indkey, indisclustered, indisvalid, indisunique, indisprimary, n.nspname,xes.indexdef,
	       indnatts, cls.reltablespace AS spcoid, spcname, tab.relname as tabname, indclass, con.oid AS conoid, CASE contype WHEN 'p' THEN desp.description WHEN 'u' THEN desp.description WHEN 'x' THEN desp.description ELSE des.description END AS description,
	       hh_get_expr(indpred, indrelid, true) as indconstraint, contype, condeferrable, condeferred, amname
	, substring(array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor 
	  FROM hh_index idx
	  JOIN hh_class cls ON cls.oid=indexrelid
	  JOIN hh_class tab ON tab.oid=indrelid
	  LEFT OUTER JOIN hh_tablespace ta on ta.oid=cls.reltablespace
	  JOIN hh_namespace n ON n.oid=tab.relnamespace
	  JOIN hh_am am ON am.oid=cls.relam
	  LEFT JOIN hh_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM hh_class WHERE relname='hh_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN hh_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	  LEFT OUTER JOIN hh_description des ON (des.objoid=cls.oid AND des.classoid='hh_class'::regclass)
	  LEFT OUTER JOIN hh_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='hh_constraint'::regclass)
	  LEFT OUTER JOIN hh_indexes xes on tab.relname=xes.tablename and xes.indexname=cls.relname
	 WHERE indrelid = ?::oid
	   AND conname IS NULL
	 ORDER BY cls.relname
				</sql>
			</prop_coll>
			<prop>
				<column name="oid" title="索引编号 " />
				<column name="名" title="名称 " />
			    <column name="owner" title="所属者" />
			    <column name="索引方法" title="索引方法" />
			    <column name="primary" title="主键" />
			    <column name="唯一" title="唯一" />
			    <column name="簇" title="簇" />
			    <column name="definition" title="定义" />
			    <column name="indkey" title="索引字段数" />
				<sql>
			SELECT 
				ci.oid AS oid,
				ci.relname AS 名,
				ct.relname AS 表名,
				am.amname 索引方法,
				i.indexrelid,
				i.indisunique as 唯一,
				i.indisclustered as 簇,
				i.indisprimary as primary,
				i.indkey,
				i.indclass,
				obj_description (indexrelid) as definition,
				i.indnatts,
				hh_get_expr (indpred, indrelid, TRUE) AS indconstraint,
				pa.rolname AS OWNER
			FROM
				hh_index i
			LEFT JOIN hh_class ct ON ct.oid = i.indrelid
			LEFT JOIN hh_class ci ON ci.oid = i.indexrelid
			LEFT JOIN hh_namespace tns ON tns.oid = ct.relnamespace
			LEFT JOIN hh_namespace ins ON ins.oid = ci.relnamespace
			LEFT JOIN hh_am am ON ci.relam = am.oid
			LEFT JOIN hh_depend dep ON dep.classid = ci.tableoid
			AND dep.objid = ci.oid
			AND dep.refobjsubid = '0'
			LEFT JOIN hh_constraint con ON con.tableoid = dep.refclassid
			AND con.oid = dep.refobjid
			LEFT JOIN hh_roles pa ON pa.oid = ci.relowner
			WHERE ct.oid=? and i.indisprimary=false
			ORDER BY ct.relname,ins.nspname,ci.relname
				</sql>
			</prop>
		</indexs>
		<!--数据表的约束查询-->
		<constraints>
		
			<prop_coll>
				<column name="name" title="名称" /> 
				<column name="condeferrable" title="可延期的" /> 
				<column name="oid" title="OID" />  
				<column name="condef" title="类型及对应字段" /> 
				<column name="description" title="注解" /> 
				<sql>
				SELECT DISTINCT conname as name,  		 --约束名称
							                contype,  		 	--类型
							                condeferrable, 	--可延期的
							                condeferred, 	 	--递延
			                                ct.relname AS tablename,
			                                cn.confdeltype,
			                                cn.confupdtype,
			                                hh_get_constraintdef(cn.oid, TRUE) AS condef,
			                                cn.oid,cn.oid as id,
							de.description
				FROM hh_class ct,hh_constraint cn
				LEFT OUTER JOIN hh_depend d ON (cn.oid = d.refobjid)
				LEFT OUTER JOIN hh_class ci ON (d.objid = ci.oid)
				LEFT OUTER JOIN hh_roles ri ON (ci.relowner = ri.oid)
				LEFT OUTER JOIN hh_description de ON (de.objoid = cn.oid)
				WHERE cn.conrelid = ct.oid
				AND ct.oid =?
				</sql>
			</prop_coll>
			
			
			<prop>
				<column name="idxname" title="名称" /> 
				<column name="oid" title="索引OID" />
				<column name="amname" title="访问方式" />
				<column name="indisunique" title="是否唯一" />
				<column name="indisprimary" title="是否主键" />
				<column name="description" title="注解" />
				
				<sql> 
				SELECT DISTINCT ON(cls.relname) cls.oid,con.conkey, cls.relname as idxname, indrelid, indkey, indisclustered, indisvalid, indisunique, indisprimary, n.nspname,
	       indnatts, cls.reltablespace AS spcoid, spcname, tab.relname as tabname, indclass, con.oid AS conoid, CASE contype WHEN 'p' THEN desp.description WHEN 'u' THEN desp.description WHEN 'x' THEN desp.description ELSE des.description END AS description,
	       hh_get_expr(indpred, indrelid, true) as indconstraint, contype, condeferrable, condeferred, amname
	, substring(array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor 
	  FROM hh_index idx
	  JOIN hh_class cls ON cls.oid=indexrelid
	  JOIN hh_class tab ON tab.oid=indrelid
	  LEFT OUTER JOIN hh_tablespace ta on ta.oid=cls.reltablespace
	  JOIN hh_namespace n ON n.oid=tab.relnamespace
	  JOIN hh_am am ON am.oid=cls.relam
	  LEFT JOIN hh_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM hh_class WHERE relname='hh_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN hh_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	  LEFT OUTER JOIN hh_description des ON (des.objoid=cls.oid AND des.classoid='hh_class'::regclass)
	  LEFT OUTER JOIN hh_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='hh_constraint'::regclass)
	 WHERE indrelid = ?::oid   AND contype='p' --表oid
	
	   AND con.oid=?::oid --约束oid
	 ORDER BY cls.relname
				</sql>
			</prop>
		</constraints>
		<!--数据表的触发器查询-->
		<triggers>
			<prop_coll>
				<column name="name" title="触发器名称" /> 
				<column name="deferrable" title="延迟" /> 
				<column name="id" title="触发器ID" /> 
				<column name="definition" title="定义" /> 
				<sql>
				SELECT c.relname,
						       t.tgname AS name,		--触发器名称
						       t.tgdeferrable AS deferrable,
						       t.tginitdeferred AS init_deferrable,
						       hh_get_triggerdef(t.oid, TRUE) AS definition,
						       t.oid AS id
						FROM hh_trigger t,hh_class c
						WHERE t.tgrelid = c.oid
					   AND t.tgisinternal = FALSE
					   AND c.oid = ?		--表ID
					   ORDER BY 1,2
				
				</sql>
			</prop_coll>
		</triggers>
		<foreignkey>
			<prop_coll>
				<sql>
					SELECT ci.indkey,c.conindid,c.oid, c.conname, c.contype, c.condeferrable, c.condeferred, 
					c.conkey, c.confupdtype, c.confdeltype, c.consrc, t.relname, 
					fns.nspname AS foreign_schema, f.relname AS foreign_table, c.conexclop,obj_description(c.oid) AS comment 
					FROM hh_constraint c 
					LEFT JOIN hh_namespace ns ON (c.connamespace = ns.oid) 
					LEFT JOIN hh_class t ON (c.conrelid = t.oid)  
					LEFT JOIN hh_class f ON (c.confrelid = f.oid) 
					LEFT JOIN hh_namespace fns ON (f.relnamespace = fns.oid)
					LEFT JOIN hh_index ci ON (c.conindid = ci.indexrelid) WHERE t.oid=? and c.contype='f';
				</sql>
			</prop_coll>
			<prop>
				<sql>
					select attname from hh_attribute where attrelid=? and attnum in (?);
				</sql>
			</prop>
		</foreignkey>
		<!--数据表的规则查询-->
		<rules>
			<prop_coll>
			<column name="rulename" title="规则名称" /> 
			<column name="id" title="规则id" />
			<column name="type" title="类型" /> 
			<column name="enabled" title="启用" /> 
			<column name="instead" title="代替" /> 
			<column name="definition" title="定义" /> 
			
				<sql>
				SELECT c.relname AS name,				--规则名称
						       r.rulename AS rulename,		
						       r.ev_type AS type,				--类型
						       r.ev_enabled AS enabled,	--启用
						       r.is_instead AS instead,		--代替
						       hh_get_ruledef(r.oid, TRUE) AS definition,	--定义
						       r.oid AS id            --规则id
						FROM hh_rewrite r,hh_class c
						WHERE r.ev_class = c.oid
						  AND r.rulename &lt;&gt; '_RETURN'
						AND c.oid = ?
						ORDER BY 1,2				
				</sql>
			</prop_coll>
			<prop>
				<sql>
				SELECT
				c.relname,
				c.oid as id,
				r.rulename 名,
				r.oid,
				r.ev_type,
				r.is_instead 代替运行,
				hh_get_ruledef (r.oid) AS definition,
				obj_description(r.oid) AS comment
			FROM
				(
					(
						hh_rewrite r
						JOIN hh_class c ON ((c.oid = r.ev_class))
					)
					LEFT JOIN hh_namespace n ON ((n.oid = c.relnamespace))
				)
			WHERE c.oid = ?
			</sql>
			</prop>
		</rules>
		<unqiue>
			<prop_coll>
				<sql>
					SELECT c.oid, c.conname 名,c.conindid, c.contype,c.conkey,obj_description(c.oid) AS comment,
						   t.reloptions AS param FROM hh_constraint c 
						   LEFT JOIN hh_class t ON (c.conrelid = t.oid) 
					       WHERE c.contype='u' and t.oid = ? 			
				</sql>
			</prop_coll>
		</unqiue>
		<check>
			<prop_coll>
				<sql>
					SELECT c.oid, c.conname 名,c.conindid, c.contype,c.conkey,c.consrc,obj_description(c.oid) AS comment FROM hh_constraint c 
						   LEFT JOIN hh_class t ON (c.conrelid = t.oid) 
					       WHERE c.contype='c' and t.oid = ? 			
				</sql>
			</prop_coll>
		</check>
		<sequences>
			<prop_coll>
				<column name="name" title="序列" /> 
				<column name="relowner" title="所有者" /> 
				<column name="comment" title="注解" /> 
				<column name="id" title="序列id" /> 
				<!-- 需要传入参数 namespace --> 
				<sql> 
					SELECT c.relname AS name,'R' AS table_type,   d.description AS comment,   c.oid AS id , hh_get_userbyid(c.relowner) AS relowner FROM hh_class c 
	LEFT JOIN hh_description d  ON c.oid = d.objoid  AND d.objsubid = 0 , hh_namespace nsp  WHERE nsp.nspname=?	 and c.relnamespace = nsp.oid	
	AND c.relkind = 'S'::char ORDER BY name 
				</sql>
			</prop_coll>
			
			<prop>
				<column name="relname" title="序列名" /> 
				<column name="oid" title="oid" />
				<column name="seqowner" title="所有者" /> 
				<column name="description" title="注解" />
				<sql>
				SELECT cl.oid, relname, hh_get_userbyid(relowner) AS seqowner, relacl, description,
	(SELECT array_agg(label) FROM hh_seclabels sl1 WHERE sl1.objoid=cl.oid) AS labels,
	(SELECT array_agg(provider) FROM hh_seclabels sl2 WHERE sl2.objoid=cl.oid) AS providers
	  FROM hh_class cl
	  LEFT OUTER JOIN hh_description des ON (des.objoid=cl.oid AND des.classoid='hh_class'::regclass)
	 WHERE relkind = 'S' AND relnamespace  = ?::oid
	   AND cl.oid=?::oid			
				</sql>
			</prop>
		</sequences>
		<functions>
			<prop_coll>
				<column name="id" title="OID" /> 
				<column name="proname" title="函数" /> 
				<!-- <column name="funcowner" title="所有者" /> 
				<column name="comment" title="注解" />  -->
				<!-- 需要传入参数 namespace --> 
				<sql> 
	SELECT proname AS proname,		--函数名称
					       p.oid AS id,			--函数ID
					      hh_catalog.hh_get_function_arguments(p.oid) AS arguments
				FROM hh_proc p
				WHERE p.pronamespace IN (select oid from hh_namespace where nspname=?)
				ORDER BY proname
				</sql>
			</prop_coll>
			<prop>
				<column name="proname" title="名称" /> 
				<column name="oid" title="OID" /> 
				<column name="funcowner" title="拥有者" /> 
				<column name="proargnames" title="参数" /> 
				<column name="nspname" title="返回类型模式" /> 
				<column name="typname" title="返回类型" /> 
				<column name="lanname" title="语言" /> 
				<column name="prosrc" title="主体" /> 
				<!-- 需要传入参数 namespace --> 
				<sql> 
					SELECT p.oid, p.proname,p.proisstrict, p.proretset, p.provolatile, 
					p.prosrc, p.probin, obj_description(p.oid) AS comment, hh_get_userbyid(p.proowner) AS funcowner, typ.typname,
					 typns.nspname, lng.lanname , p.proargnames , p.proargmodes, p.proallargtypes , p.procost, p.prorows, p.proconfig ,
					  hh_get_expr(p.proargdefaults,'hh_proc'::regclass) AS defaultvalues FROM hh_proc p 
					  JOIN hh_type typ ON typ.oid=p.prorettype JOIN hh_namespace typns ON typns.oid=typ.typnamespace 
					  JOIN hh_namespace prons ON prons.oid=p.pronamespace JOIN hh_language lng ON lng.oid=p.prolang 
					  WHERE proisagg = false AND typ.typname != 'trigger' AND prons.nspname = ? and p.oid=?
				</sql>
			</prop>
			<source>
				<sql>
				SELECT proname,p.prosrc,
					       l.lanname,
					       hh_catalog.hh_get_function_result(p.oid) AS result_type,
					       hh_catalog.hh_get_function_arguments(p.oid) AS arguments
					FROM hh_proc p,
					     hh_language l
					WHERE p.prolang = l.oid
					  AND p.oid = ?
				</sql>
			</source>
		</functions>
		<trigger>
			<prop_coll>
				<column name="proname" title="触发器" /> 
				<column name="funcowner" title="所有者" /> 
				<column name="comment" title="注解" /> 
				<!-- 需要传入参数 namespace --> 
				<sql> 
					SELECT pr.oid, pr.xmin, pr.*, format_type(TYP.oid, NULL) AS typname, typns.nspname AS typnsp, lanname, proargnames, hh_get_expr(proargdefaults, 'hh_catalog.hh_class'::regclass) AS proargdefaultvals, pronargdefaults, proconfig,        hh_get_userbyid(proowner) as funcowner, description,
					(SELECT array_agg(label) FROM hh_seclabels sl1 WHERE sl1.objoid=pr.oid) AS labels,
					(SELECT array_agg(provider) FROM hh_seclabels sl2 WHERE sl2.objoid=pr.oid) AS providers
					  FROM hh_proc pr
					  JOIN hh_type typ ON typ.oid=prorettype
					  JOIN hh_namespace typns ON typns.oid=typ.typnamespace
					  JOIN hh_language lng ON lng.oid=prolang
					  LEFT OUTER JOIN hh_description des ON (des.objoid=pr.oid AND des.classoid='hh_proc'::regclass)
					 WHERE proisagg = FALSE AND pronamespace = ?
					AND (typname IN ('trigger', 'event_trigger') 
					AND lanname NOT IN ('edbspl', 'sql', 'internal')) ORDER BY proname
				</sql>
			</prop_coll>
			<prop>
			   <sql>
			   		SELECT t.oid,t.tgname AS trigger_name, c.relname AS trigger_table_name,
					c.relkind AS event_object_table_type,  t.tgdeferrable, 
					t.tginitdeferred,t.tgtype,
					("substring"(hh_get_triggerdef(t.oid), ("position"("substring"(hh_get_triggerdef(t.oid), 48), 'EXECUTE PROCEDURE'::text) + 47))) AS action_statement, 
					(CASE WHEN (((t.tgtype)::integer &amp; 1) = 1) THEN 'ROW'::text ELSE 'STATEMENT'::text END) AS action_orientation, 
					(CASE WHEN (((t.tgtype)::integer &amp; 2) = 2) THEN 'BEFORE'::text ELSE 'AFTER'::text END) AS condition_timing, t.tgconstraint, 
					   array_to_string(array(    
					   SELECT tc.event_object_column::text FROM information_schema.triggered_update_columns tc  WHERE tc.trigger_schema = n.nspname AND tc.trigger_name = t.tgname 
							AND tc.event_object_schema = n.nspname AND tc.event_object_table = c.relname ), ',') as event_object,
					(t.tgtype &amp; 4) tginsert,(t.tgtype &amp; 8) tgdelete,(t.tgtype &amp; 16) tgupdate,(t.tgtype &amp; 32) tgtruncate,
					 obj_description(t.oid) FROM hh_namespace n LEFT JOIN hh_class c ON (n.oid = c.relnamespace) INNER JOIN hh_trigger t ON (c.oid = t.tgrelid) 
					 where c.oid=? and t.tgisinternal = 'f'
			   </sql>
			</prop>
			<source>
			<sql>
				SELECT proname AS proname,		--函数名称
					       p.oid AS id,			--函数ID
					      hh_catalog.hh_get_function_arguments(p.oid) AS arguments
				FROM hh_proc p
				WHERE p.pronamespace IN (select oid from hh_namespace where nspname='?') 
				and hh_catalog.hh_get_function_result(p.oid)='trigger'
				ORDER BY proname;
				</sql>
			</source>
		</trigger>
		
		<repdb>
			<createTable>
				<sql>
				create table loginUser(
				loginUserID int GENERATED BY
				DEFAULT AS IDENTITY(START WITH 1 INCREMENT BY 1)
				not null,
				loginUserName varchar,
				loginUserPwd varchar,
				primary key (loginUserID)
				);
				insert into loginUser(loginUserID,loginUserName)
				values(1,'admin','');

				CREATE TABLE IF NOT EXISTS connection(
				connID
				int GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1)
				not null,
				loginUserID int DEFAULT 1,
				connName VARCHAR NOT NULL,
				--服务器名称
				connHost VARCHAR NOT NULL, --数据库连接地址
				connPort VARCHAR NOT
				NULL, --端口号
				connDbName VARCHAR NOT NULL, --数据库名称
				connUserName VARCHAR
				NOT NULL,--用户名
				connPwd VARCHAR,--密码
				createDate TIMESTAMP WITHOUT time
				ZONE,-- 连接创建时间
				PRIMARY KEY (connID),
				FOREIGN KEY (loginUserID)
				REFERENCES loginUser (loginUserID)ON DELETE
				CASCADE
				);
				</sql>
			</createTable>
		</repdb>
		<!-- 数据库状态查询 -->
		<serverstatus>
		
			<prop_coll> 
				<column name="pid" title="PID" />
				<column name="client" title="客户端" /> 
				<column name="datname" title="目标数据库" /> 
				<column name="state" title="状态" />
				<column name="query_start" title="查询开始时间" />				
				<column name="query" title="执行sql" />
				<sql>
					select pid,datname,client_addr client,state,query_start,query  from hh_stat_activity where datname = ?
				</sql>
			</prop_coll>
			
			<prop> 
				<column name="pid" title="PID" />
				<column name="client" title="客户端" /> 
				<column name="datname" title="目标数据库" /> 
				<column name="state" title="状态" />
				<column name="duration" title="已执行时间" />				
				<column name="query" title="执行sql" />
				<sql>
					select
				    pid,
				    datname,
				    query,
				    client_addr client,
				    now() - hh_stat_activity.query_start as duration ,
				    state
				from
				    hh_stat_activity 
				where
				    query &lt;&gt; ''::text 
				    and now() - hh_stat_activity.query_start > interval '1 second'
				    and state &lt;&gt; 'idle';
				</sql>
			</prop>
			
			<stat_coll> 
				<column name="query" title="执行sql" /> 
				<column name="calls" title="执行次数" /> 
				<column name="total_time" title="花费总时间" />
				<column name="rows" title="影响的行数" />				
				<sql>
					select query,total_time,calls,rows from hh_stat_statements;
				</sql>
			</stat_coll>
		</serverstatus>
		
		<!-- 数据库基础服务 -->
		<dataservice>
		    <datatypelist>
		        SELECT tn, CASE WHEN typmodin = 0
				THEN false ELSE true
				END AS has_length,
				(SELECT count(*)
				FROM hh_attribute a, hh_class c, hh_namespace n
				WHERE a.atttypid = ts.oid
				AND a.attnum > 0
				AND a.attrelid = c.oid
				AND c.relnamespace = n.oid
				AND n.nspname NOT IN ('hh_catalog', 'information_schema')) AS usage_count
				FROM (SELECT typname AS tn, typrelid, typelem, typtype, 
				typcategory, typbasetype, typmodin, oid
				FROM hh_type
				UNION SELECT format_type(oid, null) AS tn,
				typrelid, 
				typelem, 
				typtype, 
				typcategory, 
				typbasetype, 
				typmodin, 
				oid
				FROM hh_type) AS ts 
				WHERE typrelid = 0 
				AND typelem = 0
				AND typtype != 'p' 
				AND typcategory != 'X' 
				AND typbasetype = 0
				UNION SELECT 'serial', false, 0 
				UNION SELECT 'bigserial', false, 0
				ORDER BY 1
		    </datatypelist>
		    <languagelist>
				SELECT lanname as name, oid as id FROM hh_language WHERE lanname NOT IN ('internal', 'c') ORDER BY lanname
		    </languagelist>
		    <rolelist>
				SELECT rolname as name, oid as id  FROM hh_roles ORDER BY rolname
		    </rolelist>
		    <serverlist>
				SELECT srvname as name, oid  as id  FROM hh_foreign_server
		    </serverlist>
		    <classname>
				SELECT n.nspname, c.relname FROM hh_class c, hh_namespace n WHERE c.relnamespace = n.oid   AND c.oid = ?
		    </classname>
		    <functionname>
				SELECT n.nspname, p.proname, hh_get_function_identity_arguments(p.oid) as args  FROM hh_proc p, hh_namespace n WHERE p.pronamespace = n.oid AND p.oid = ?
		    </functionname>
		    <typename>
				SELECT n.nspname, t.typname FROM hh_type t, hh_namespace n WHERE t.typnamespace = n.oid AND (t.oid = ? OR t.typrelid = ?)
		    </typename>
			<classforname>
				org.hhdbsql.Driver
		    </classforname>
		    <!-- 连接数据库时，设置连接地址数据库对应名称 -->
		    <urlname>
				hhdbsql
		    </urlname>
		     <!-- 连接数据库时，设置默认初始化数据库 -->
			<dbname>
				hhdb
			</dbname>
			 <dbversion>
				SELECT * from hh_catalog.hh_class where relname = 'hhxc_class'
		    </dbversion>
			<dbaschema>
				"hh_temp_3", "hh_toast", "hh_toast_temp_3", "hh_catalog", "information_schema", "webadmin"
			</dbaschema>
			<!-- 导出SQL使用的脚本 -->
			<seqsqls>
			    select hh_class.*,hh_authid.rolname from hh_class,hh_authid where relname like '%_seq' and hh_authid.oid=hh_class.relowner and hh_authid.rolname=
			</seqsqls>
			<setval>
			    SELECT hh_catalog.setval
			</setval>
		</dataservice>
		
			<types> <!-- 数据类型 -->
 		    <prop_coll>
 		        <column name="name" title="类型名称" />
				<column name="type_kind" title="类型" /> 
				<column name="id" title="id" />
				<sql>
 		        SELECT t.typname AS name,		--类型名称
					       t.typtype AS type_kind,
					       c.oid AS id
					FROM hh_type t,
					     hh_class c
					WHERE t.typnamespace = ?
					  AND t.typrelid = c.oid
					  AND t.typtype = 'c'
					  AND c.relkind = 'c'
					UNION
					SELECT d.typname,
					       d.typtype,
					       d.oid
					FROM hh_type d
					WHERE d.typnamespace = ?
					  AND d.typtype IN ('d', 'e','r')
					ORDER BY name
				</sql>
	        </prop_coll> 		        
			<prop> 
				<sql>
					SELECT tn, CASE WHEN typmodIN = 0 THEN FALSE ELSE TRUE END AS has_length,   (
					SELECT count(*)     
					  FROM hh_ATTRIBUTE a, hh_CLASS c, hh_namespace n    
					 WHERE a.atttypid = ts.oid     
					   AND a.attnum > 0     
					   AND a.attrelid = c.oid 			     
					   AND c.relnamespace = n.oid     
					   AND n.nspNAME NOT IN ('hh_catalog', 'information_schema')) AS usage_count 
					  FROM (
					SELECT typNAME AS tn, typrelid, typelem, typtype,  typcategory, typbasetype, typmodin, oid    
					  FROM hh_TYPE    UNION   
					SELECT format_type(oid, null) AS tn,typrelid, typelem, typtype, typcategory, typbasetype, typmodin, oid    
					  FROM hh_type) AS ts 
					 WHERE typrelid = 0 
					   AND typelem = 0 
					   AND typTYPE != 'p' 
					   AND typcategory != 'X' 
					   AND typbasetype = 0  UNION 
					SELECT 'serial', false, 0  UNION 
					SELECT 'bigserial', false, 0 
					 ORDER BY 1
				</sql>
			</prop>
			
			
		
			<!-- 类型实例 -->
			<prop_item>
 		        <column name="name" title="类型名称" />
				<column name="id" title="id" />
				<column name="type_kind" title="类型" /> 
				<sql>
 		        	SELECT t.typname AS name, c.oid AS id,t.typtype AS type_kind
					FROM hh_type t, hh_class c
					WHERE t.typnamespace = ? 	AND t.typrelid=?  AND t.typrelid = c.oid  
					UNION
					SELECT d.typname,d.oid,d.typtype
					FROM hh_type d
					WHERE d.typnamespace = ? 	AND d.oid=?
					 
				</sql>
	        </prop_item>
	        <!--composite类型脚本  -->
			<compositesource>
				<sql>
					SELECT a.attname, 
					hh_catalog.format_type(a.atttypid, a.atttypmod) as datatype 
					FROM hh_type t, hh_class c, hh_attribute a 
					WHERE t.typrelid = c.oid 
					AND c.reltype=t.oid
					AND c.oid = a.attrelid 
					AND t.typtype = 'c' 
					AND c.relkind = 'c' 
					AND c.oid = ? 
					AND a.attnum > 0 
					AND NOT a.attisdropped 
					ORDER BY a.attnum
				</sql>
			</compositesource>
			<!--basic类型脚本  -->
			<basicsource>
				<sql>
					SELECT hh_catalog.format_type(t.typbasetype, t.typtypmod) as base_type, 
					hh_catalog.array_to_string(ARRAY(
					SELECT hh_catalog.hh_get_constraintdef(r.oid, true) 
					FROM hh_catalog.hh_constraint r 
					WHERE t.oid = r.contypid), ' ') as check,
					typdefault, 
					typnotnull 
					FROM hh_type t 
					WHERE t.typtype = 'd' 
					AND t.oid = ?
				</sql>
			</basicsource>
			<!-- enum类型脚本 -->
			<enumsource>
				<sql>
					SELECT e.enumlabel
					FROM hh_type t, hh_enum e 
					WHERE t.oid = e.enumtypid 
					AND t.typtype = 'e'
					AND t.oid = ? 
					ORDER BY e.enumsortorder 
				</sql>
			</enumsource>
		</types>
		<!--服务器信息-->
		<dbserver>
			<stat_coll>
   				<column name="pid" title="PID" />
				<column name="application_name" title="应用程序名" />
				<column name="datname" title="数据库" />
				<column name="usename" title="用户" />
				<column name="client_addr" title="客户端" />
				<column name="client_port" title="客户端端口" />
				<column name="backend_start" title="客户端启动" />
				<column name="query_start" title="查询开始" />
				<column name="xact_start" title="TX开始" />
				<column name="state" title="状态" />
				<column name="state_change" title="状态变化时间" />
				<column name="query" title="查询" />
				<sql>
					select * from hh_stat_activity
				</sql>
			</stat_coll>
			<!--准备完毕事物 -->
			<prop_coll>
    			<column name="transaction" title="XID" />
				<column name="gid" title="全局ID" />
				<column name="prepared" title="时间" />
				<column name="owner" title="所有者" />
				<column name="database" title="数据库" />
				<sql>
					select * from hh_prepared_xacts
				</sql>
			</prop_coll>
			
			<!--数据库服务器cpu实时监控 -->
			<cpu_monitor>
    			<column name="cpu_combined" title="CPU总体情况(百分数)" />
				<column name="cpu_idle" title="CPU空闲(百分数)" />
				<sql>
					select array_to_string((dbmon_cpuinfo()::varchar[][])[1:array_length((dbmon_cpuinfo()::varchar[][]),1)][9:9], ',', '*') as cpu_combined
					,
					array_to_string((dbmon_cpuinfo()::varchar[][])[1:array_length((dbmon_cpuinfo()::varchar[][]),1)][4:4], ',', '*') as cpu_idle  
				</sql>
			</cpu_monitor>
			
			<!--数据库服务器内存实时监控 -->
			<mem_monitor>
    			<column name="total_size" title="内存总计(MB)" />
				<column name="usered_siz" title="已用(MB)" />
				<column name="free_size" title="可用(MB)" />
				<sql>
					select (dbmon_free()::int[])[2]/1024 as total_size, (dbmon_free()::int[])[3]/1024 as usered_siz, (dbmon_free()::int[])[4]/1024 as free_size
				</sql>
			</mem_monitor>
			
			<!--数据库服务器cpu实时监控 -->
			<cpu_info>
				<column name="cpu_info" title="CPU信息" />
				<sql>
					select  sys_util('cpu_util.sh','cpu_info') as cpu_info;
				</sql>
			</cpu_info>
			<!--获取CPU实时简要信息 -->
			<cpu_perf>
				<column name="cpu_perf" title="CPU实时简要信息" />
				<sql>
					select  sys_util('cpu_util.sh','cpu_perf') as cpu_perf;
				</sql>
			</cpu_perf>
			<!--获取实时内存信息 -->
			<show_mem>
				<column name="show_mem" title="实时内存信息" />
				<sql>
					select  sys_util('mem_util.sh','show_mem') as show_mem;
				</sql>
			</show_mem>
			<!--实时获取硬盘简要使用信息 -->
			<show_disk_perf>
				<column name="show_disk_perf" title="硬盘简要使用信息" />
				<sql>
					select  sys_util('disk_util.sh','show_disk_perf') as show_disk_perf;
				</sql>
			</show_disk_perf>
			<!-- 2、实时获取硬盘详细使用信息 -->
			<show_disk_usage>
				<column name="show_disk_usage" title="硬盘详细使用信息 " />
				<sql>
					select  sys_util('disk_util.sh','show_disk_usage') as show_disk_usage;
				</sql>
			</show_disk_usage>
			<!--获取进程信息，根据CPU排序 -->
			<show_ps_top_cpu>
				<column name="show_ps_top_cpu" title="进程信息-CPU排序 " />
				<sql>
					select  sys_util('ps_util.sh','show_ps_top_cpu') as show_ps_top_cpu;
				</sql>
			</show_ps_top_cpu>
			<!--获取所有进程信息，根据内存排序 -->
			<show_ps_top_mem>
				<column name="show_ps_top_mem" title="进程信息-内存排序 " />
				<sql>
					select  sys_util('ps_util.sh','show_ps_top_mem') as show_ps_top_mem;
				</sql>
			</show_ps_top_mem>
			<!--关键字查询进程详细信息 -->
			<show_ps_by_grep>
				<column name="show_ps_info" title="关键字查询进程" />
				<sql>
					select  sys_util('ps_util.sh',?) as show_ps_info;
				</sql>
			</show_ps_by_grep>
			<!--获取操作系统信息 -->
			<os_info>
				<column name="os_info" title="操作系统信息" />
				<sql>
					select  sys_util('sys_util.sh','os_info') as os_info;
				</sql>
			</os_info>
			
			<!--获取服务器网络监控信息 -->
			<eth_info>
				<column name="eth_list" title="网络监控信息 " />
				<sql>
					select  sys_util('eth_util.sh','eth_list') as eth_list;
				</sql>
			</eth_info>
			 
			<!--获取复制监控信息 -->
			<show_copy> 
				<column name="pid" title="pid" />
				<column name="usesysid" title="usesysid" />
				<column name="usename" title="usename" />
				<column name="application_name" title="application_name" />
				<column name="client_addr" title="client_addr" />
				<column name="client_hostname" title="client_hostname" />
				<column name="client_port" title="client_port" />
				<column name="backend_start" title="backend_start" />
				<column name="backend_xmin" title="backend_xmin" />
				<column name="state" title="state" />
				<column name="sent_location" title="sent_location" />
				<column name="write_location" title="write_location" />
				<column name="flush_location" title="flush_location" />
				<column name="replay_location" title="replay_location" />
				<column name="sync_priority" title="sync_priority" />
				<column name="sync_state" title="sync_state" />
				<column name="hhxlog" title="hhxlog" />
				<sql>
					select  *,hh_xlog_location_diff(sent_location, replay_location) as hhxlog  from hh_stat_replication
				</sql>
			</show_copy>
				<!--获取备机延迟时间信息 -->
			<show_copyback> 
				<column name="log_delay" title="log_delay" />
				<sql>
					SELECT CASE WHEN hh_last_xlog_receive_location() = hh_last_xlog_replay_location()
					THEN 0
					ELSE EXTRACT (EPOCH FROM now() - hh_last_xact_replay_timestamp())
				    END AS log_delay;
				</sql>
			</show_copyback>
		</dbserver>
		
		<!--模式 -->
		<extend>
			<prop>
				<column title="扩展ID" name="refobjid" />
				<column title="扩展名称" name="extendName" />
				<column title="状态" name="status" />
				<column title="扩展内容" name="desc" /> 
				<sql>
					SELECT refobjid,string_agg(hh_catalog.hh_describe_object(classid, objid, 0),' ;') AS "desc",'' status,'' extendName
					FROM hh_catalog.hh_depend
					WHERE refclassid = 'hh_catalog.hh_extension'::hh_catalog.regclass AND refobjid in (SELECT e.oid
					FROM hh_catalog.hh_extension e
					WHERE e.extname = ?
					ORDER BY 1) AND deptype = 'e'
				    group by refobjid;
				</sql>
			</prop>
			<prop_coll>
				<column name="name" title="extname" />
				<column name="extowner" title="extowner" />
				<column name="extnamespace" title="extnamespace" />
				<column name="extrelocatable" title="extrelocatable" /> 
				<column name="extversion" title="extversion" />
				<column name="extconfig" title="extconfig" />
				<column name="extcondition" title="extcondition" />
				<sql>
				select extname as name,extowner,extnamespace,extrelocatable,extversion,extconfig,extcondition from hh_extension;
				</sql>
			</prop_coll>
			<create>
				<column name="extname" title="extname" />
				<sql>
				create extension ?
				</sql>
			</create>
			<drop>
				<column name="extname" title="extname" />
				<sql>
				drop extension ? cascade
				</sql>
			</drop>
		</extend>
		<!-- 数据库锁查询 -->
		<lockstatus>
			<prop_coll> 
				<column name="pid" title="PID" />
				<column name="datname" title="数据库" />
				<column name="usename" title="用户" />
				<column name="client_addr" title="客户端地址" />
				<column name="locktype" title="锁类型" /> 
				<column name="mode" title="模式" /> 
				<column name="query_start" title="开始时间" />
				<column name="query" title="执行sql" />
				<sql>
					select distinct c.pid,a.locktype,a.mode,c.datname,c.usename,c.client_addr,c.query_start,c.query
					from hh_locks a
					join hh_class b on a.relation = b.oid left join hh_stat_activity c on a.pid=c.pid;
				</sql>
			</prop_coll>
		</lockstatus>
		<authorization>
			<prop_coll> 
			<sql>
				CREATE OR REPLACE FUNCTION public.g_or_v(g_or_v text, own name, target name, objtyp text, exp text[], priv text) RETURNS void AS $BODY$ 
					declare
					  nsp name;
					  rel name;
					  sql text;
					  tmp_nsp name := '';
					begin
					  for nsp,rel in select t2.nspname,t1.relname from hh_class t1,hh_namespace t2 where t1.relkind=objtyp and t1.relnamespace=t2.oid and t1.relowner=(select oid from hh_roles where rolname=own)
					  loop
					    if (tmp_nsp = '' or tmp_nsp &lt;&gt; nsp) and lower(g_or_v)='grant' then
					      -- auto grant schema to target user
					      sql := 'GRANT usage on schema "'||nsp||'" to '||target;
					      execute sql;
					      raise notice '%', sql;
					    end if;
					
					    tmp_nsp := nsp;
					
					    if (exp is not null and nsp||'.'||rel = any (exp)) then
					      raise notice '% excluded % .', g_or_v, nsp||'.'||rel;
					    else
					      if lower(g_or_v) = 'grant' then
					        sql := g_or_v||' '||priv||' on "'||nsp||'"."'||rel||'" to '||target ;
					      elsif lower(g_or_v) = 'revoke' then
					        sql := g_or_v||' '||priv||' on "'||nsp||'"."'||rel||'" from '||target ;
					      else
					        raise notice 'you must enter grant or revoke';
						      end if;
						      raise notice '%', sql;
						      execute sql;
						    end if;
						  end loop;
						end;
						$BODY$ LANGUAGE plhhsql VOLATILE;
				</sql>
				</prop_coll>
		</authorization>
	</sql>
</sqls>