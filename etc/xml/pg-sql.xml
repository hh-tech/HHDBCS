<?xml version="1.0" encoding="utf-8"?>
<sqls>
	<sql>

		<!--数据库集合 -->
		<database>
			<prop_coll>
				<column name="id" title="OID" />
				<column name="datname" title="数据库名称" />
				<column name="usename" title="所属者 " />
				<column name="spcname" title="所属表空间  " />
				<column name="description" title="注解  " />
				<sql>
					SELECT pg_database.oid as id,
					datname,usename,spcname,descr.description
					FROM
					pg_database  LEFT OUTER JOIN pg_shdescription descr ON(pg_database.oid=descr.objoid AND descr.classoid='pg_database'::regclass),pg_user u,pg_tablespace t 
					WHERE
					datdba=u.usesysid
					AND
					dattablespace=t.oid
					and datname not in('template0','template1')
				</sql>
			</prop_coll>

			<stat_coll>
				<column name="datname" title="数据库名称" />
				<column name="numbackends" title="后台进程数" />
				
				<column name="xact_commit" title="Xct已提交 " />
				<column name="xact_rollback" title="Xct已回滚 " />
				
				<column name="blks_read" title="块读取 " />
				<column name="blks_hit" title="块命中 " />

				<column name="tup_returned" title="已返回元组" />
				<column name="tup_fetched" title="已提取元组" />
				<column name="tup_inserted" title="已插入元组" />
				<column name="tup_updated" title="已更新元组" />
				<column name="tup_deleted" title="已删除元组" />
				
				<column name="conflicts" title="冲突" />
				<column name="temp_files" title="临时文件" />
				<column name="temp_bytes" title="临时字节 " />
				<column name="deadlocks" title="死锁 " />
				<column name="stats_reset" title="最后统计重置  " />
			
				<sql>SELECT * FROM pg_stat_database</sql>
			</stat_coll>
			<!--数据库实例 -->
			<prop>
				<column name="datname" title="数据库名称" />
				<column name="usename" title="所有者" />
				<column name="size" title="数据库大小" />
				<column name="spcname" title="所属表空间" />
				<column name="datconnlimit" title="连接数限制" />
				<column name="datcollate" title="字符排序" />
				<column name="datctype" title="字符分类" />
				
				<sql>
					SELECT
					*,pg_size_pretty(pg_database_size(pg_database.datname))
					AS size
					FROM
					pg_database,pg_user u,pg_tablespace t
					WHERE
					datdba=u.usesysid
					AND
					dattablespace=t.oid
					AND datname=?
				</sql>
			</prop>

			<stat>
				<column name="datname" title="数据库名称" />
				<column name="numbackends" title="后台进程数" />
				
				<column name="xact_commit" title="Xct已提交 " />
				<column name="xact_rollback" title="Xct已回滚 " />
				
				<column name="blks_read" title="块读取 " />
				<column name="blks_hit" title="块命中 " />

				<column name="tup_returned" title="已返回元组" />
				<column name="tup_fetched" title="已提取元组" />
				<column name="tup_inserted" title="已插入元组" />
				<column name="tup_updated" title="已更新元组" />
				<column name="tup_deleted" title="已删除元组" />
				
				<column name="conflicts" title="冲突" />
				<column name="temp_files" title="临时文件" />
				<column name="temp_bytes" title="临时字节 " />
				<column name="deadlocks" title="死锁 " />
				<column name="stats_reset" title="最后统计重置  " />
				<sql>
					SELECT * from pg_stat_database
					WHERE datname=?
				</sql>
			</stat>
			
			
			<create>
				<column name="dbName" title="数据库名称  " />
				<column name="usename" title="所有者  " />
				<column name="datconnlimit" title="连接数限制  " />
				<sql>
				CREATE DATABASE ?
  					WITH ENCODING='UTF8'
       				OWNER=?
       				CONNECTION LIMIT=?;
				</sql>
			</create>
			
			<drop>
				<column name="dbName" title="数据库名称  " />
				<sql>
				DROP DATABASE ?
				</sql>
			</drop>
			
		</database>

		<!--表空间集合 -->

		<tablespace>
			<prop_coll> 
				<column name="spcname" title="表空间" />
				<column name="usename" title="所有者" /> 
				<column name="size" title="大小" />
				<column name="tbs_local" title="位置" /> 
				<column name="description" title="注解  " />
				<sql>
					SELECT u.usename,
					pg_catalog.shobj_description(oid, 'pg_tablespace') AS description,
					pg_tablespace.spcname,
					pg_size_pretty(pg_tablespace_size(pg_tablespace.spcname)) AS size,
					pg_tablespace_location(oid) tbs_local
					FROM pg_tablespace ,pg_user u
		WHERE spcowner=u.usesysid
				</sql>
			</prop_coll>
			
			<!--表空间实例 -->
			<prop>
				<column name="spcname" title="表空间" />
				<column name="usename" title="所有者" /> 
				<column name="size" title="大小" />
				<column name="description" title="注解  " />
				<sql>
					SELECT u.usename,
					pg_catalog.shobj_description(oid, 'pg_tablespace') AS description,
					pg_tablespace.spcname,
					pg_size_pretty(pg_tablespace_size(pg_tablespace.spcname)) AS size,
					pg_tablespace_location(oid) tbs_local
					FROM pg_tablespace ,pg_user u
					WHERE spcowner=u.usesysid and pg_tablespace.spcname=?
				</sql>
			</prop>

			<stat>
			</stat>
		</tablespace>
 		<types> <!-- 数据类型 -->
			<prop> 
				<sql>
					SELECT tn, CASE WHEN typmodIN = 0 THEN FALSE ELSE TRUE END AS has_length,   (
					SELECT count(*)     
					  FROM pg_ATTRIBUTE a, pg_CLASS c, pg_namespace n    
					 WHERE a.atttypid = ts.oid     
					   AND a.attnum > 0     
					   AND a.attrelid = c.oid 			     
					   AND c.relnamespace = n.oid     
					   AND n.nspNAME NOT IN ('pg_catalog', 'information_schema')) AS usage_count 
					  FROM (
					SELECT typNAME AS tn, typrelid, typelem, typtype,  typcategory, typbasetype, typmodin, oid    
					  FROM pg_TYPE    UNION   
					SELECT format_type(oid, null) AS tn,typrelid, typelem, typtype, typcategory, typbasetype, typmodin, oid    
					  FROM pg_type) AS ts 
					 WHERE typrelid = 0 
					   AND typelem = 0 
					   AND typTYPE != 'p' 
					   AND typcategory != 'X' 
					   AND typbasetype = 0  UNION 
					SELECT 'serial', false, 0  UNION 
					SELECT 'bigserial', false, 0 
					 ORDER BY 1
				</sql>
			</prop>
		</types>
		<role> <!-- 用户角色 -->
			<prop_coll> 
				<column name="rolname" title="角色名称" /> 
				<column name="description" title="注解" /> 
				<sql>
					SELECT tab.oid, tab.*, pg_catalog.shobj_description(tab.oid, 'pg_authid') AS description,
	(SELECT array_agg(label) FROM pg_shseclabel sl1 WHERE sl1.objoid=tab.oid) AS labels,
	(SELECT array_agg(provider) FROM pg_shseclabel sl2 WHERE sl2.objoid=tab.oid) AS providers FROM pg_authid tab WHERE NOT rolcanlogin ORDER BY rolname
				</sql>
			</prop_coll>
		</role>
		<!--用户集合 -->
		<user>
			<!--登陆用户集合属性 -->
			<prop_coll>
				<column name="id" title="OID" /> 
				<column name="rolname" title="用户名称" /> 
				<column name="description" title="注解" /> 
				<sql> 
					SELECT tab.oid as id, tab.*, pg_catalog.shobj_description(tab.oid, 'pg_authid') AS description,
	(SELECT array_agg(label) FROM pg_shseclabel sl1 WHERE sl1.objoid=tab.oid) AS labels,
	(SELECT array_agg(provider) FROM pg_shseclabel sl2 WHERE sl2.objoid=tab.oid) AS providers FROM pg_authid tab WHERE rolcanlogin ORDER BY rolname					
				</sql>
			</prop_coll>
			
			<prop>
				<column name="rolname" title="用户名称" /> 
				<column name="rolsuper" title="超级用户" /> 
				<column name="rolcreaterole" title="创建角色" /> 
				<column name="rolcreatedb" title="创建数据库" /> 
				<column name="rolcanlogin" title="可以登录" /> 
				<sql> 
				SELECT rolname, rolsuper, rolinherit, rolcreaterole, rolcreatedb,  
				rolcanlogin, oid FROM pg_roles where oid=?
				</sql>
			</prop>
		</user>

		<!--模式 -->
		<schema>
			<!--模式集合属性 -->
			<prop_coll>
				<column name="name" title="模式名称" />
				<column name="usename" title="所有者" />
				<sql>
					SELECT nspname as name,
					oid as id,
					usename
					FROM pg_namespace,pg_user u
					WHERE nspowner=u.usesysid
					AND nspname NOT
					IN
					('information_schema', 'pg_catalog','pg_toast')
					AND nspname NOT LIKE E'pg\\_temp\\_%'AND nspname NOT LIKE E'pg\\_toast_temp\\_%'
					ORDER BY nspname
				</sql>
			</prop_coll>
			<prop>
				<column name="nspname" title="模式名称" />
				<column name="namespaceowner" title="创建者" />
				<column name="nspacl" title="所有者" />
				<column name="oid" title="oid" /> 
				<column name="description" title="注解" />
				<sql>
					SELECT CASE WHEN nspname LIKE E'hh\\_temp\\_%' THEN 1
	            WHEN (nspname LIKE E'hh\\_%') THEN 0
	            ELSE 3 END AS nsptyp,
	       nsp.nspname, nsp.oid, pg_get_userbyid(nspowner) AS namespaceowner, nspacl, description,       has_schema_privilege(nsp.oid, 'CREATE') as cancreate,
	(SELECT array_agg(label) FROM pg_seclabels sl1 WHERE sl1.objoid=nsp.oid) AS labels,
	(SELECT array_agg(provider) FROM pg_seclabels sl2 WHERE sl2.objoid=nsp.oid) AS providers
	  FROM pg_namespace nsp
	  LEFT OUTER JOIN pg_description des ON (des.objoid=nsp.oid AND des.classoid='pg_namespace'::regclass)
	 WHERE nsp.oid=?::oid
	   AND NOT ((nspname = 'pg_catalog' AND EXISTS (SELECT 1 FROM pg_class WHERE relname = 'pg_class' AND relnamespace = nsp.oid LIMIT 1)) OR
	(nspname = 'hhagent' AND EXISTS (SELECT 1 FROM pg_class WHERE relname = 'hha_job' AND relnamespace = nsp.oid LIMIT 1)) OR
	(nspname = 'information_schema' AND EXISTS (SELECT 1 FROM pg_class WHERE relname = 'tables' AND relnamespace = nsp.oid LIMIT 1)) OR
	(nspname LIKE '_%' AND EXISTS (SELECT 1 FROM pg_proc WHERE proname='slonyversion' AND pronamespace = nsp.oid LIMIT 1))
	)  AND nspname NOT LIKE E'hh\\_temp\\_%'AND nspname NOT LIKE E'hh\\_toast_temp\\_%' ORDER BY 1, nspname
				</sql>
			</prop>
		</schema>
		
		<table>
			<prop_coll>
				<column name="id" title="oid" />
				<column name="name" title="数据表" /> 
				<column name="relowner" title="所有者" /> 
				<column name="comment" title="注解" /> 
				<!-- 需要传入参数 namespace --> 
				<sql> 
					SELECT c.relname AS name,'R' AS table_type,   d.description AS comment,  c.oid AS id , pg_get_userbyid(c.relowner) AS relowner FROM pg_class c 
	LEFT JOIN pg_description d  ON c.oid = d.objoid  AND d.objsubid = 0 , pg_namespace nsp  WHERE nsp.nspname=?	 and c.relnamespace = nsp.oid	
	AND c.relkind = 'r' ORDER BY c.relname 
				</sql>
			</prop_coll>
			<prop>
				<column name="relname" title="表名称" /> 
				<!-- <column name="spcname" title="表空间" />  -->
				<column name="oid" title="oid" />
				<column name="relowner" title="创建者" />
				<column name="relacl" title="所有者" />
				<column name="conkey" title="主键" />
				<column name="description" title="注解" />  
				<sql>
	SELECT rel.oid, rel.relname, rel.reltablespace AS spcoid, spc.spcname, pg_get_userbyid(rel.relowner) AS relowner, rel.relacl, rel.relhasoids, rel.relhassubclass, rel.reltuples, des.description, con.conname, con.conkey,
	        rel.relpersistence , spc.*
	   FROM pg_class rel
	  LEFT OUTER JOIN pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_class tst ON tst.oid = rel.reltoastrelid
	 LEFT JOIN pg_type typ ON rel.reloftype=typ.oid
	 WHERE rel.relkind IN ('r','s','t') AND rel.relnamespace = ?::oid
	 and rel.relname=?
	 ORDER BY rel.relname
				</sql>
			</prop> 
			<columnspaykey>
				<sql>
					select pg_constraint.conname as pk_name,pg_attribute.attname as colname,pg_type.typname as typename,ss.ordinal_position from pg_constraint 
					inner join pg_class  on pg_constraint.conrelid = pg_class.oid  inner join pg_attribute on pg_attribute.attrelid = pg_class.oid  and  pg_attribute.attnum = any(pg_constraint.conkey) 
					inner join pg_type on pg_type.oid = pg_attribute.atttypid inner join pg_catalog.pg_namespace n on n.oid = pg_class.relnamespace
					inner join  (select * from information_schema.columns where table_schema='?' and table_name='?') ss on pg_attribute.attname=ss.column_name 
					where pg_class.relname = '?' and pg_constraint.contype='p' and n.nspname='?' 
				</sql>
			</columnspaykey> 		
			<columnsinfo>
				<sql>
					SELECT col.table_name, col.column_name 名称, COALESCE(col.character_maximum_length,  col.numeric_precision) 长度,
					case WHEN  is_nullable='NO' then true when is_nullable='YES' THEN FALSE end as 不是null,col.numeric_scale 小数点,col.datetime_precision, 
					col.ordinal_position as position, b.atttypmod, b.attndims, col.data_type AS col_type, et.typelem, et.typlen, et.typtype, b.atttypid, col.udt_schema,
					col.udt_name 类型, col.column_default AS col_default, col_description(c.oid, col.ordinal_position) AS comment, b.attacl, 
					coll.collname FROM information_schema.columns AS col LEFT JOIN pg_namespace ns ON ns.nspname = col.table_schema LEFT JOIN pg_class c ON col.table_name = c.relname
					AND c.relnamespace = ns.oid LEFT JOIN pg_attrdef a ON c.oid = a.adrelid AND col.ordinal_position = a.adnum LEFT JOIN pg_attribute b ON b.attrelid = c.oid AND b.attname = col.column_name
					LEFT JOIN pg_type et ON et.oid = b.atttypid LEFT JOIN pg_collation coll ON coll.oid = b.attcollation
					WHERE c.oid=? ORDER BY col.table_name, col.ordinal_position
				</sql>
			</columnsinfo> 		
			<columnsbyname>
				<sql>
						select column_name 名称,udt_name 类型,COALESCE(character_maximum_length ,numeric_precision) 长度,numeric_scale 小数点,case WHEN  is_nullable='NO' then true 
						 when is_nullable='YES' THEN FALSE end 不是null,ordinal_position as position from information_schema.columns 
						where table_schema='?' and table_name = '?'
				</sql>
			</columnsbyname> 	
			<!--  获取外键表字段 -->	
			<attname>
				<sql>
					select attname from pg_attribute where attrelid=? and attnum in (?)
				</sql>
			</attname> 		
			<!--  获取索引字段 -->	
			<indexdef>
				<sql>
					SELECT pg_get_indexdef (?, ?, TRUE)
				</sql>
			</indexdef> 		
		</table>
		<fittable>
			<prop_coll>
				<column name="column_name" title="名称" /> 
				<column name="udt_name" title="类型" /> 
				<column name="length" title="长度" /> 
				<column name="numeric_scale" title="小数点" /> 
				<column name="is_null" title="不是null" /> 
				<column name="parkey" title="主键" /> 
				<column name="position" title="position" /> 
				<!-- 需要传入参数 namespace --> 
				<sql> 
				select column_name,udt_name,COALESCE(character_maximum_length ,numeric_precision) length,numeric_scale,case WHEN  is_nullable='NO' then true
					when is_nullable='YES' THEN FALSE end is_null,ordinal_position as position,'' as parkey from information_schema.columns
					where table_schema=? and table_name = ?
				</sql>
			</prop_coll>
			<prop>
				<column name="pk_name" title="pk_name" /> 
				<column name="colname" title="colname" /> 
				<column name="typename" title="typename" />
				<column name="ordinal_position" title="ordinal_position" />
				<sql>
					select pg_constraint.conname as pk_name,pg_attribute.attname as colname,pg_type.typname as typename,ss.ordinal_position from pg_constraint
					inner join pg_class  on pg_constraint.conrelid = pg_class.oid  inner join pg_attribute on pg_attribute.attrelid = pg_class.oid  and  pg_attribute.attnum = any(pg_constraint.conkey) 
					inner join pg_type on pg_type.oid = pg_attribute.atttypid inner join pg_catalog.pg_namespace n on n.oid = pg_class.relnamespace 
					inner join  (select * from information_schema.columns where table_schema=? and table_name=?) ss on pg_attribute.attname=ss.column_name 
					where pg_class.relname = ? and pg_constraint.contype='p' and n.nspname=?;
				</sql>
			</prop> 
		</fittable>
		<view>
			<prop_coll>
				<column name="id" title="OID" /> 
				<column name="name" title="视图" /> 
				<column name="relowner" title="所有者" /> 
				<column name="comment" title="注解" /> 
				<!-- 需要传入参数 namespace --> 
				<sql> 
					SELECT c.relname AS name,'R' AS table_type,   d.description AS comment,   c.oid AS id , pg_get_userbyid(c.relowner) AS relowner FROM pg_class c 
	LEFT JOIN pg_description d  ON c.oid = d.objoid  AND d.objsubid = 0 , pg_namespace nsp  WHERE nsp.nspname=?	 and c.relnamespace = nsp.oid	
	AND c.relkind = 'v'::char ORDER BY name 
	
				</sql>
			</prop_coll>
			
			<prop>
				<column name="relname" title="视图名称" /> 
				<column name="ev_class" title="oid" /> 
				 <column name="nspname" title="模式" /> 
				<column name="definition" title="定义" />
				<column name="owner" title="所有者" />
				<column name="description" title="注解" />  
				<sql>
					SELECT rw.oid, rw.*, relname, CASE WHEN relkind = 'r' THEN TRUE ELSE FALSE END AS parentistable, nspname, description,
			       pg_get_ruledef(rw.oid, true) AS definition 
				,pg_get_userbyid(cl.relowner) as owner
			  FROM pg_rewrite rw
			  JOIN pg_class cl ON cl.oid=rw.ev_class
			  JOIN pg_namespace nsp ON nsp.oid=cl.relnamespace
			  LEFT OUTER JOIN pg_description des ON (des.objoid=rw.oid AND des.classoid='pg_rewrite'::regclass)
			 WHERE ev_class = ?
			 ORDER BY rw.rulename
				</sql>
			</prop>
			
		</view>
		
		
		
	    <!--表字段 -->
		<columns>
			<prop_coll>
			<column name="name" title="列名" /> 
			<column name="datatype" title="数据类型" /> 
			<column name="nullable" title="非空" /> 
			<column name="default_value" title="默认值" /> 
			<column name="primary_key" title="是否主键" />
			<column name="comment" title="注解" /> 
			<sql>
				SELECT a.attname AS name,				
				       pg_catalog.format_type (a.atttypid, a.atttypmod) AS datatype,			--数据类型
				       a.attnotnull AS NULLABLE,					--可空的
				       a.attnum AS id,			 -- ID
				  (SELECT SUBSTRING (pg_catalog.pg_get_expr (d.adbin, d.adrelid)
				                     FOR 128) AS default_value
				   FROM pg_catalog.pg_attrdef d
				   WHERE d.adrelid = a.attrelid
					AND d.adnum = a.attnum
					AND a.atthasdef) AS default_value,		 --默认值
				       EXISTS
				  (SELECT 1
				   FROM
				     (SELECT unnest(conkey) attnum
				      FROM pg_constraint
				      WHERE conrelid = a.attrelid
				        AND contype = 'p') c
				   WHERE c.attnum =a.attnum) AS primary_key,			--主键
				              FALSE AS distribution_key,			--外键
				              d.description AS COMMENT 		--注释
				FROM pg_attribute a
				LEFT OUTER JOIN pg_description d 
				ON (a.attrelid = d.objoid AND d.objsubid = a.attnum)
				WHERE a.attrelid =? 									--表ID
				AND a.attnum > 0
				AND NOT a.attisdropped
				ORDER BY a.attnum	
				</sql>			
			</prop_coll>
			
			<prop>
				<column name="attname" title="列名" /> 
				<column name="attnotnull" title="不能为空" /> 
				<column name="attrelid" title="oid" />
				<column name="typname" title="数据类型" />
				<column name="attlen" title="长度" />
				<column name="isfk" title="是否外键" />
				<column name="description" title="注解" />  
				<sql>
	SELECT att.*, def.*, pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval, CASE WHEN att.attndims > 0 THEN 1 ELSE 0 END AS isarray, format_type(ty.oid,NULL) AS typname, format_type(ty.oid,att.atttypmod) AS displaytypname, tn.nspname as typnspname, et.typname as elemtypname,
	  ty.typstorage AS defaultstorage, cl.relname, na.nspname, att.attstattarget, description, cs.relname AS sername, ns.nspname AS serschema,
	  (SELECT count(1) FROM pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup, indkey,
	  coll.collname, nspc.nspname as collnspname,
	  attoptions,
	  EXISTS(SELECT 1 FROM  pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As isfk,
	(SELECT array_agg(label) FROM pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS labels,
	(SELECT array_agg(provider) FROM pg_seclabels sl2 WHERE sl2.objoid=att.attrelid AND sl2.objsubid=att.attnum) AS providers
	  FROM pg_attribute att
	  JOIN pg_type ty ON ty.oid=atttypid
	  JOIN pg_namespace tn ON tn.oid=ty.typnamespace
	  JOIN pg_class cl ON cl.oid=att.attrelid
	  JOIN pg_namespace na ON na.oid=cl.relnamespace
	  LEFT OUTER JOIN pg_type et ON et.oid=ty.typelem
	  LEFT OUTER JOIN pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_depend JOIN pg_class cs ON objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_namespace ns ON ns.oid=cs.relnamespace
	  LEFT OUTER JOIN pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_namespace nspc ON coll.collnamespace=nspc.oid
	 WHERE att.attrelid = ?::oid
	   AND att.attnum=?
	   AND att.attnum > 0
	   AND att.attisdropped IS FALSE
	 ORDER BY att.attnum
				</sql>
			</prop> 
		</columns>
		<!--数据表的索引查询-->
		<indexs>
			<prop_coll>
				<column name="idxname" title="名称" /> 
				<column name="id" title="索引OID" />
				<column name="tabname" title="所属表" />
				<column name="amname" title="访问方式" />
				<column name="description" title="注解" />
				<sql>
				SELECT DISTINCT ON(cls.relname) cls.oid as id, cls.relname as idxname, indrelid, indkey, indisclustered, indisvalid, indisunique, indisprimary, n.nspname,
	       indnatts, cls.reltablespace AS spcoid, spcname, tab.relname as tabname, indclass, con.oid AS conoid, CASE contype WHEN 'p' THEN desp.description WHEN 'u' THEN desp.description WHEN 'x' THEN desp.description ELSE des.description END AS description,
	       pg_get_expr(indpred, indrelid, true) as indconstraint, contype, condeferrable, condeferred, amname
	, substring(array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor 
	  FROM pg_index idx
	  JOIN pg_class cls ON cls.oid=indexrelid
	  JOIN pg_class tab ON tab.oid=indrelid
	  LEFT OUTER JOIN pg_tablespace ta on ta.oid=cls.reltablespace
	  JOIN pg_namespace n ON n.oid=tab.relnamespace
	  JOIN pg_am am ON am.oid=cls.relam
	  LEFT JOIN pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	  LEFT OUTER JOIN pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	 WHERE indrelid = ?::oid
	   AND conname IS NULL
	 ORDER BY cls.relname
				</sql>
			</prop_coll>
			<prop>
				<column name="oid" title="索引编号 " />
				<column name="名" title="名称 " />
			    <column name="owner" title="所属者" />
			    <column name="索引方法" title="索引方法" />
			    <column name="primary" title="主键" />
			    <column name="唯一" title="唯一" />
			    <column name="簇" title="簇" />
			    <column name="definition" title="定义" />
			    <column name="indkey" title="索引字段数" />
				<sql>
			SELECT 
				ci.oid AS oid,
				ci.relname AS 名,
				ct.relname AS 表名,
				am.amname 索引方法,
				i.indexrelid,
				i.indisunique as 唯一,
				i.indisclustered as 簇,
				i.indisprimary as primary,
				i.indkey,
				i.indclass,
				obj_description (indexrelid) as definition,
				i.indnatts,
				pg_get_expr (indpred, indrelid, TRUE) AS indconstraint,
				pa.rolname AS OWNER
			FROM
				pg_index i
			LEFT JOIN pg_class ct ON ct.oid = i.indrelid
			LEFT JOIN pg_class ci ON ci.oid = i.indexrelid
			LEFT JOIN pg_namespace tns ON tns.oid = ct.relnamespace
			LEFT JOIN pg_namespace ins ON ins.oid = ci.relnamespace
			LEFT JOIN pg_am am ON ci.relam = am.oid
			LEFT JOIN pg_depend dep ON dep.classid = ci.tableoid
			AND dep.objid = ci.oid
			AND dep.refobjsubid = '0'
			LEFT JOIN pg_constraint con ON con.tableoid = dep.refclassid
			AND con.oid = dep.refobjid
			LEFT JOIN pg_roles pa ON pa.oid = ci.relowner
			WHERE ct.oid=? and i.indisprimary=false
			ORDER BY ct.relname,ins.nspname,ci.relname
				</sql>
			</prop>
		</indexs>
		<!--数据表的约束查询-->
		<constraints>
		
			<prop_coll>
				<column name="name" title="名称" /> 
				<column name="condeferrable" title="可延期的" /> 
				<column name="oid" title="OID" />  
				<column name="condef" title="类型及对应字段" /> 
				<column name="description" title="注解" /> 
				<sql>
				SELECT DISTINCT conname as name,  		 --约束名称
							                contype,  		 	--类型
							                condeferrable, 	--可延期的
							                condeferred, 	 	--递延
			                                ct.relname AS tablename,
			                                cn.confdeltype,
			                                cn.confupdtype,
			                                pg_get_constraintdef(cn.oid, TRUE) AS condef,
			                                cn.oid,cn.oid as id,
							de.description
				FROM pg_class ct,pg_constraint cn
				LEFT OUTER JOIN pg_depend d ON (cn.oid = d.refobjid)
				LEFT OUTER JOIN pg_class ci ON (d.objid = ci.oid)
				LEFT OUTER JOIN pg_roles ri ON (ci.relowner = ri.oid)
				LEFT OUTER JOIN pg_description de ON (de.objoid = cn.oid)
				WHERE cn.conrelid = ct.oid
				AND ct.oid =?
				</sql>
			</prop_coll>
			
			
			<prop>
				<column name="idxname" title="名称" /> 
				<column name="oid" title="索引OID" />
				<column name="amname" title="访问方式" />
				<column name="indisunique" title="是否唯一" />
				<column name="indisprimary" title="是否主键" />
				<column name="description" title="注解" />
				
				<sql> 
				SELECT DISTINCT ON(cls.relname) cls.oid,con.conkey, cls.relname as idxname, indrelid, indkey, indisclustered, indisvalid, indisunique, indisprimary, n.nspname,
	       indnatts, cls.reltablespace AS spcoid, spcname, tab.relname as tabname, indclass, con.oid AS conoid, CASE contype WHEN 'p' THEN desp.description WHEN 'u' THEN desp.description WHEN 'x' THEN desp.description ELSE des.description END AS description,
	       pg_get_expr(indpred, indrelid, true) as indconstraint, contype, condeferrable, condeferred, amname
	, substring(array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor 
	  FROM pg_index idx
	  JOIN pg_class cls ON cls.oid=indexrelid
	  JOIN pg_class tab ON tab.oid=indrelid
	  LEFT OUTER JOIN pg_tablespace ta on ta.oid=cls.reltablespace
	  JOIN pg_namespace n ON n.oid=tab.relnamespace
	  JOIN pg_am am ON am.oid=cls.relam
	  LEFT JOIN pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	  LEFT OUTER JOIN pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	 WHERE indrelid = ?::oid   AND contype='p' --表oid
	
	   AND con.oid=?::oid --约束oid
	 ORDER BY cls.relname
				</sql>
			</prop>
		</constraints>
		<!--数据表的触发器查询-->
		<triggers>
			<prop_coll>
				<column name="name" title="触发器名称" /> 
				<column name="deferrable" title="延迟" /> 
				<column name="definition" title="定义" /> 
				<sql>
				SELECT c.relname,
						       t.tgname AS name,		--触发器名称
						       t.tgdeferrable AS deferrable,
						       t.tginitdeferred AS init_deferrable,
						       pg_get_triggerdef(t.oid, TRUE) AS definition,
						       t.oid AS id
						FROM pg_trigger t,pg_class c
						WHERE t.tgrelid = c.oid
					   AND t.tgisinternal = FALSE
					   AND c.oid = ?		--表ID
					   ORDER BY 1,2
				
				</sql>
			</prop_coll>
		</triggers>
		<foreignkey>
			<prop_coll>
				<sql>
					SELECT ci.indkey,c.conindid,c.oid, c.conname, c.contype, c.condeferrable, c.condeferred, 
					c.conkey, c.confupdtype, c.confdeltype, c.consrc, t.relname, 
					fns.nspname AS foreign_schema, f.relname AS foreign_table, c.conexclop,obj_description(c.oid) AS comment 
					FROM pg_constraint c 
					LEFT JOIN pg_namespace ns ON (c.connamespace = ns.oid) 
					LEFT JOIN pg_class t ON (c.conrelid = t.oid)  
					LEFT JOIN pg_class f ON (c.confrelid = f.oid) 
					LEFT JOIN pg_namespace fns ON (f.relnamespace = fns.oid)
					LEFT JOIN pg_index ci ON (c.conindid = ci.indexrelid) WHERE t.oid=? and c.contype='f';
				</sql>
			</prop_coll>
			<prop>
				<sql>
					select attname from pg_attribute where attrelid=? and attnum in (?);
				</sql>
			</prop>
		</foreignkey>
		<!--数据表的规则查询-->
		<rules>
			<prop_coll>
			<column name="rulename" title="规则名称" /> 
			<column name="type" title="类型" /> 
			<column name="enabled" title="启用" /> 
			<column name="instead" title="代替" /> 
			<column name="definition" title="定义" /> 
				<sql>
				SELECT c.relname AS name,				--规则名称
						       r.rulename AS rulename,		
						       r.ev_type AS type,				--类型
						       r.ev_enabled AS enabled,	--启用
						       r.is_instead AS instead,		--代替
						       pg_get_ruledef(r.oid, TRUE) AS definition,	--定义
						       r.oid AS id
						FROM pg_rewrite r,pg_class c
						WHERE r.ev_class = c.oid
						  AND r.rulename &lt;&gt; '_RETURN'
						AND c.oid = ?
						ORDER BY 1,2				
				</sql>
			</prop_coll>
			<prop>
				<sql>
				SELECT
				c.relname,
				c.oid as id,
				r.rulename 名,
				r.oid,
				r.ev_type,
				r.is_instead 代替运行,
				pg_get_ruledef (r.oid) AS definition,
				obj_description(r.oid) AS comment
			FROM
				(
					(
						pg_rewrite r
						JOIN pg_class c ON ((c.oid = r.ev_class))
					)
					LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))
				)
			WHERE c.oid = ?
			</sql>
			</prop>
		</rules>
		<unqiue>
			<prop_coll>
				<sql>
					SELECT c.oid, c.conname 名,c.conindid, c.contype,c.conkey,obj_description(c.oid) AS comment,
						   t.reloptions AS param FROM pg_constraint c 
						   LEFT JOIN pg_class t ON (c.conrelid = t.oid) 
					       WHERE c.contype='u' and t.oid = ? 			
				</sql>
			</prop_coll>
		</unqiue>
		<check>
			<prop_coll>
				<sql>
					SELECT c.oid, c.conname 名,c.conindid, c.contype,c.conkey,c.consrc,obj_description(c.oid) AS comment FROM pg_constraint c 
						   LEFT JOIN pg_class t ON (c.conrelid = t.oid) 
					       WHERE c.contype='c' and t.oid = ? 			
				</sql>
			</prop_coll>
		</check>
		<sequences>
			<prop_coll>
				<column name="name" title="序列" /> 
				<column name="relowner" title="所有者" /> 
				<column name="comment" title="注解" /> 
				<column name="id" title="序列id" /> 
				<!-- 需要传入参数 namespace --> 
				<sql> 
					SELECT c.relname AS name,'R' AS table_type,   d.description AS comment,   c.oid AS id , pg_get_userbyid(c.relowner) AS relowner FROM pg_class c 
	LEFT JOIN pg_description d  ON c.oid = d.objoid  AND d.objsubid = 0 , pg_namespace nsp  WHERE nsp.nspname=?	 and c.relnamespace = nsp.oid	
	AND c.relkind = 'S'::char ORDER BY name 
				</sql>
			</prop_coll>
			
			<prop>
				<column name="relname" title="序列名" /> 
				<column name="oid" title="oid" />
				<column name="seqowner" title="所有者" /> 
				<column name="description" title="注解" />
				<sql>
				SELECT cl.oid, relname, pg_get_userbyid(relowner) AS seqowner, relacl, description,
	(SELECT array_agg(label) FROM pg_seclabels sl1 WHERE sl1.objoid=cl.oid) AS labels,
	(SELECT array_agg(provider) FROM pg_seclabels sl2 WHERE sl2.objoid=cl.oid) AS providers
	  FROM pg_class cl
	  LEFT OUTER JOIN pg_description des ON (des.objoid=cl.oid AND des.classoid='pg_class'::regclass)
	 WHERE relkind = 'S' AND relnamespace  = ?::oid
	   AND cl.oid=?::oid			
				</sql>
			</prop>
		</sequences>
		<functions>
			<prop_coll>
				<column name="id" title="OID" /> 
				<column name="proname" title="函数" /> 
				<!-- <column name="funcowner" title="所有者" /> 
				<column name="comment" title="注解" />  -->
				<!-- 需要传入参数 namespace --> 
				<sql> 
	SELECT proname AS proname,		--函数名称
					       p.oid AS id,			--函数ID
					      pg_catalog.pg_get_function_arguments(p.oid) AS arguments
				FROM pg_proc p
				WHERE p.pronamespace IN (select oid from pg_namespace where nspname=?)
				ORDER BY proname
				</sql>
			</prop_coll>
			<prop>
				<column name="proname" title="名称" /> 
				<column name="oid" title="OID" /> 
				<column name="funcowner" title="拥有者" /> 
				<column name="proargnames" title="参数" /> 
				<column name="nspname" title="返回类型模式" /> 
				<column name="typname" title="返回类型" /> 
				<column name="lanname" title="语言" /> 
				<column name="prosrc" title="主体" /> 
				<!-- 需要传入参数 namespace --> 
				<sql> 
					SELECT p.oid, p.proname,p.proisstrict, p.proretset, p.provolatile, 
					p.prosrc, p.probin, obj_description(p.oid) AS comment, pg_get_userbyid(p.proowner) AS funcowner, typ.typname,
					 typns.nspname, lng.lanname , p.proargnames , p.proargmodes, p.proallargtypes , p.procost, p.prorows, p.proconfig ,
					  pg_get_expr(p.proargdefaults,'pg_proc'::regclass) AS defaultvalues FROM pg_proc p 
					  JOIN pg_type typ ON typ.oid=p.prorettype JOIN pg_namespace typns ON typns.oid=typ.typnamespace 
					  JOIN pg_namespace prons ON prons.oid=p.pronamespace JOIN pg_language lng ON lng.oid=p.prolang 
					  WHERE proisagg = false AND typ.typname != 'trigger' AND prons.nspname = ? and p.oid=?
				</sql>
			</prop>
			<source>
				<sql>
				SELECT proname,p.prosrc,
					       l.lanname,
					       pg_catalog.pg_get_function_result(p.oid) AS result_type,
					       pg_catalog.pg_get_function_arguments(p.oid) AS arguments
					FROM pg_proc p,
					     pg_language l
					WHERE p.prolang = l.oid
					  AND p.oid = ?
				</sql>
			</source>
		</functions>
		<trigger>
			<prop_coll>
				<column name="proname" title="触发器" /> 
				<column name="funcowner" title="所有者" /> 
				<column name="comment" title="注解" /> 
				<!-- 需要传入参数 namespace --> 
				<sql> 
					SELECT pr.oid, pr.xmin, pr.*, format_type(TYP.oid, NULL) AS typname, typns.nspname AS typnsp, lanname, proargnames, pg_get_expr(proargdefaults, 'pg_catalog.pg_class'::regclass) AS proargdefaultvals, pronargdefaults, proconfig,        pg_get_userbyid(proowner) as funcowner, description,
					(SELECT array_agg(label) FROM pg_seclabels sl1 WHERE sl1.objoid=pr.oid) AS labels,
					(SELECT array_agg(provider) FROM pg_seclabels sl2 WHERE sl2.objoid=pr.oid) AS providers
					  FROM pg_proc pr
					  JOIN pg_type typ ON typ.oid=prorettype
					  JOIN pg_namespace typns ON typns.oid=typ.typnamespace
					  JOIN pg_language lng ON lng.oid=prolang
					  LEFT OUTER JOIN pg_description des ON (des.objoid=pr.oid AND des.classoid='pg_proc'::regclass)
					 WHERE proisagg = FALSE AND pronamespace = ?
					AND (typname IN ('trigger', 'event_trigger') 
					AND lanname NOT IN ('edbspl', 'sql', 'internal')) ORDER BY proname
				</sql>
			</prop_coll>
			<prop>
			   <sql>
			   		SELECT t.oid,t.tgname AS trigger_name, c.relname AS trigger_table_name,
					c.relkind AS event_object_table_type,  t.tgdeferrable, 
					t.tginitdeferred,t.tgtype,
					("substring"(pg_get_triggerdef(t.oid), ("position"("substring"(pg_get_triggerdef(t.oid), 48), 'EXECUTE PROCEDURE'::text) + 47))) AS action_statement, 
					(CASE WHEN (((t.tgtype)::integer &amp; 1) = 1) THEN 'ROW'::text ELSE 'STATEMENT'::text END) AS action_orientation, 
					(CASE WHEN (((t.tgtype)::integer &amp; 2) = 2) THEN 'BEFORE'::text ELSE 'AFTER'::text END) AS condition_timing, t.tgconstraint, 
					   array_to_string(array(    
					   SELECT tc.event_object_column::text FROM information_schema.triggered_update_columns tc  WHERE tc.trigger_schema = n.nspname AND tc.trigger_name = t.tgname 
							AND tc.event_object_schema = n.nspname AND tc.event_object_table = c.relname ), ',') as event_object,
					(t.tgtype &amp; 4) tginsert,(t.tgtype &amp; 8) tgdelete,(t.tgtype &amp; 16) tgupdate,(t.tgtype &amp; 32) tgtruncate,
					 obj_description(t.oid) FROM pg_namespace n LEFT JOIN pg_class c ON (n.oid = c.relnamespace) INNER JOIN pg_trigger t ON (c.oid = t.tgrelid) 
					 where c.oid=? and t.tgisinternal = 'f'
			   </sql>
			</prop>
			<source>
			<sql>
				SELECT proname AS proname,		--函数名称
					       p.oid AS id,			--函数ID
					      pg_catalog.pg_get_function_arguments(p.oid) AS arguments
				FROM pg_proc p
				WHERE p.pronamespace IN (select oid from pg_namespace where nspname='?') 
				and pg_catalog.pg_get_function_result(p.oid)='trigger'
				ORDER BY proname;
				</sql>
			</source>
		</trigger>
		
		<repdb>
			<createTable>
				<sql>
				create table loginUser(
				loginUserID int GENERATED BY
				DEFAULT AS IDENTITY(START WITH 1 INCREMENT BY 1)
				not null,
				loginUserName varchar,
				loginUserPwd varchar,
				primary key (loginUserID)
				);
				insert into loginUser(loginUserID,loginUserName)
				values(1,'admin','');

				CREATE TABLE IF NOT EXISTS connection(
				connID
				int GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1)
				not null,
				loginUserID int DEFAULT 1,
				connName VARCHAR NOT NULL,
				--服务器名称
				connHost VARCHAR NOT NULL, --数据库连接地址
				connPort VARCHAR NOT
				NULL, --端口号
				connDbName VARCHAR NOT NULL, --数据库名称
				connUserName VARCHAR
				NOT NULL,--用户名
				connPwd VARCHAR,--密码
				createDate TIMESTAMP WITHOUT time
				ZONE,-- 连接创建时间
				PRIMARY KEY (connID),
				FOREIGN KEY (loginUserID)
				REFERENCES loginUser (loginUserID)ON DELETE
				CASCADE
				);
				</sql>
			</createTable>
		</repdb>
		<!-- 数据库状态查询 -->
		<serverstatus>
		
			<prop_coll> 
				<column name="pid" title="PID" />
				<column name="client" title="客户端" /> 
				<column name="datname" title="目标数据库" /> 
				<column name="state" title="状态" />
				<column name="query_start" title="查询开始时间" />				
				<column name="query" title="执行sql" />
				<sql>
					select pid,datname,client_addr client,state,query_start,query  from pg_stat_activity where datname = ?
				</sql>
			</prop_coll>
			
			<prop> 
				<column name="pid" title="PID" />
				<column name="client" title="客户端" /> 
				<column name="datname" title="目标数据库" /> 
				<column name="state" title="状态" />
				<column name="duration" title="已执行时间" />				
				<column name="query" title="执行sql" />
				<sql>
					select
				    pid,
				    datname,
				    query,
				    client_addr client,
				    now() - pg_stat_activity.query_start as duration ,
				    state
				from
				    pg_stat_activity 
				where
				    query &lt;&gt; ''::text 
				    and now() - pg_stat_activity.query_start > interval '1 second'
				    and state &lt;&gt; 'idle';
				</sql>
			</prop>
			
			<stat_coll> 
				<column name="query" title="执行sql" /> 
				<column name="calls" title="执行次数" /> 
				<column name="total_time" title="花费总时间" />
				<column name="rows" title="影响的行数" />				
				<sql>
					select query,total_time,calls,rows from pg_stat_statements;
				</sql>
			</stat_coll>
		</serverstatus>
		
		<!-- 数据库基础服务 -->
		<dataservice>
		    <datatypelist>
		        SELECT tn, CASE WHEN typmodin = 0
				THEN false ELSE true
				END AS has_length,
				(SELECT count(*)
				FROM pg_attribute a, pg_class c, pg_namespace n
				WHERE a.atttypid = ts.oid
				AND a.attnum > 0
				AND a.attrelid = c.oid
				AND c.relnamespace = n.oid
				AND n.nspname NOT IN ('pg_catalog', 'information_schema')) AS usage_count
				FROM (SELECT typname AS tn, typrelid, typelem, typtype, 
				typcategory, typbasetype, typmodin, oid
				FROM pg_type
				UNION SELECT format_type(oid, null) AS tn,
				typrelid, 
				typelem, 
				typtype, 
				typcategory, 
				typbasetype, 
				typmodin, 
				oid
				FROM pg_type) AS ts 
				WHERE typrelid = 0 
				AND typelem = 0
				AND typtype != 'p' 
				AND typcategory != 'X' 
				AND typbasetype = 0
				UNION SELECT 'serial', false, 0 
				UNION SELECT 'bigserial', false, 0
				ORDER BY 1
		    </datatypelist>
		    <languagelist>
				SELECT lanname as name, oid as id FROM pg_language WHERE lanname NOT IN ('internal', 'c') ORDER BY lanname
		    </languagelist>
		    <rolelist>
				SELECT rolname as name, oid as id  FROM pg_roles ORDER BY rolname
		    </rolelist>
		    <serverlist>
				SELECT srvname as name, oid  as id  FROM pg_foreign_server
		    </serverlist>
		    <classname>
				SELECT n.nspname, c.relname FROM pg_class c, pg_namespace n WHERE c.relnamespace = n.oid   AND c.oid = ?
		    </classname>
		    <functionname>
				SELECT n.nspname, p.proname, pg_get_function_identity_arguments(p.oid) as args  FROM pg_proc p, pg_namespace n WHERE p.pronamespace = n.oid AND p.oid = ?
		    </functionname>
		    <typename>
				SELECT n.nspname, t.typname FROM pg_type t, pg_namespace n WHERE t.typnamespace = n.oid AND (t.oid = ? OR t.typrelid = ?)
		    </typename>
			<classforname>
				org.postgresql.Driver
		    </classforname>
		     <!-- 连接数据库时，设置默认初始化数据库 -->
			<dbname>
				postgres
			</dbname>
			<dbaschema>
				"pg_temp_3", "pg_toast", "pg_toast_temp_3", "pg_catalog", "information_schema", "webadmin"
			</dbaschema>
			<!-- 导出SQL使用的脚本 -->
			<seqsqls>
			    select pg_class.*,pg_authid.rolname from pg_class,pg_authid where relname like '%_seq' and pg_authid.oid=pg_class.relowner and pg_authid.rolname=
			</seqsqls>
			<setval>
			    SELECT pg_catalog.setval
			</setval>
		</dataservice>
		
			<types> <!-- 数据类型 -->
 		    <prop_coll>
 		        <column name="name" title="类型名称" />
				<column name="type_kind" title="类型" /> 
				<column name="id" title="id" />
				<sql>
 		        SELECT t.typname AS name,		--类型名称
					       t.typtype AS type_kind,
					       c.oid AS id
					FROM pg_type t,
					     pg_class c
					WHERE t.typnamespace = ?
					  AND t.typrelid = c.oid
					  AND t.typtype = 'c'
					  AND c.relkind = 'c'
					UNION
					SELECT d.typname,
					       d.typtype,
					       d.oid
					FROM pg_type d
					WHERE d.typnamespace = ?
					  AND d.typtype IN ('d', 'e','r')
					ORDER BY name
				</sql>
	        </prop_coll> 		        
			<prop> 
				<sql>
					SELECT tn, CASE WHEN typmodIN = 0 THEN FALSE ELSE TRUE END AS has_length,   (
					SELECT count(*)     
					  FROM pg_ATTRIBUTE a, pg_CLASS c, pg_namespace n    
					 WHERE a.atttypid = ts.oid     
					   AND a.attnum > 0     
					   AND a.attrelid = c.oid 			     
					   AND c.relnamespace = n.oid     
					   AND n.nspNAME NOT IN ('pg_catalog', 'information_schema')) AS usage_count 
					  FROM (
					SELECT typNAME AS tn, typrelid, typelem, typtype,  typcategory, typbasetype, typmodin, oid    
					  FROM pg_TYPE    UNION   
					SELECT format_type(oid, null) AS tn,typrelid, typelem, typtype, typcategory, typbasetype, typmodin, oid    
					  FROM pg_type) AS ts 
					 WHERE typrelid = 0 
					   AND typelem = 0 
					   AND typTYPE != 'p' 
					   AND typcategory != 'X' 
					   AND typbasetype = 0  UNION 
					SELECT 'serial', false, 0  UNION 
					SELECT 'bigserial', false, 0 
					 ORDER BY 1
				</sql>
			</prop>
			
			
		
			<!-- 类型实例 -->
			<prop_item>
 		        <column name="name" title="类型名称" />
				<column name="id" title="id" />
				<column name="type_kind" title="类型" /> 
				<sql>
 		        	SELECT t.typname AS name, c.oid AS id,t.typtype AS type_kind
					FROM pg_type t, pg_class c
					WHERE t.typnamespace = ? 	AND t.typrelid=?  AND t.typrelid = c.oid  
					UNION
					SELECT d.typname,d.oid,d.typtype
					FROM pg_type d
					WHERE d.typnamespace = ? 	AND d.oid=?
					 
				</sql>
	        </prop_item>
	        <!--composite类型脚本  -->
			<compositesource>
				<sql>
					SELECT a.attname, 
					pg_catalog.format_type(a.atttypid, a.atttypmod) as datatype 
					FROM pg_type t, pg_class c, pg_attribute a 
					WHERE t.typrelid = c.oid 
					AND c.reltype=t.oid
					AND c.oid = a.attrelid 
					AND t.typtype = 'c' 
					AND c.relkind = 'c' 
					AND c.oid = ? 
					AND a.attnum > 0 
					AND NOT a.attisdropped 
					ORDER BY a.attnum
				</sql>
			</compositesource>
			<!--basic类型脚本  -->
			<basicsource>
				<sql>
					SELECT pg_catalog.format_type(t.typbasetype, t.typtypmod) as base_type, 
					pg_catalog.array_to_string(ARRAY(
					SELECT pg_catalog.pg_get_constraintdef(r.oid, true) 
					FROM pg_catalog.pg_constraint r 
					WHERE t.oid = r.contypid), ' ') as check,
					typdefault, 
					typnotnull 
					FROM pg_type t 
					WHERE t.typtype = 'd' 
					AND t.oid = ?
				</sql>
			</basicsource>
			<!-- enum类型脚本 -->
			<enumsource>
				<sql>
					SELECT e.enumlabel
					FROM pg_type t, pg_enum e 
					WHERE t.oid = e.enumtypid 
					AND t.typtype = 'e'
					AND t.oid = ? 
					ORDER BY e.enumsortorder 
				</sql>
			</enumsource>
		</types>
		<!--服务器信息-->
		<dbserver>
			<stat_coll>
   				<column name="pid" title="PID" />
				<column name="application_name" title="应用程序名" />
				<column name="datname" title="数据库" />
				<column name="usename" title="用户" />
				<column name="client_addr" title="客户端" />
				<column name="client_port" title="客户端端口" />
				<column name="backend_start" title="客户端启动" />
				<column name="query_start" title="查询开始" />
				<column name="xact_start" title="TX开始" />
				<column name="state" title="状态" />
				<column name="state_change" title="状态变化时间" />
				<column name="query" title="查询" />
				<sql>
					select * from pg_stat_activity
				</sql>
			</stat_coll>
			<!--准备完毕事物 -->
			<prop_coll>
    			<column name="transaction" title="XID" />
				<column name="gid" title="全局ID" />
				<column name="prepared" title="时间" />
				<column name="owner" title="所有者" />
				<column name="database" title="数据库" />
				<sql>
					select * from pg_prepared_xacts
				</sql>
			</prop_coll>
			
			<!--数据库服务器cpu实时监控 -->
			<cpu_monitor>
    			<column name="cpu_combined" title="CPU总体情况(百分数)" />
				<column name="cpu_idle" title="CPU空闲(百分数)" />
				<sql>
					select array_to_string((dbmon_cpuinfo()::varchar[][])[1:array_length((dbmon_cpuinfo()::varchar[][]),1)][9:9], ',', '*') as cpu_combined
					,
					array_to_string((dbmon_cpuinfo()::varchar[][])[1:array_length((dbmon_cpuinfo()::varchar[][]),1)][4:4], ',', '*') as cpu_idle  
				</sql>
			</cpu_monitor>
			
			<!--数据库服务器内存实时监控 -->
			<mem_monitor>
    			<column name="total_size" title="内存总计(MB)" />
				<column name="usered_siz" title="已用(MB)" />
				<column name="free_size" title="可用(MB)" />
				<sql>
					select (dbmon_free()::int[])[2]/1024 as total_size, (dbmon_free()::int[])[3]/1024 as usered_siz, (dbmon_free()::int[])[4]/1024 as free_size
				</sql>
			</mem_monitor>
			
			<!--数据库服务器cpu实时监控 -->
			<cpu_info>
				<column name="cpu_info" title="CPU信息" />
				<sql>
					select  sys_util('cpu_util.sh','cpu_info') as cpu_info;
				</sql>
			</cpu_info>
			<!--获取CPU实时简要信息 -->
			<cpu_perf>
				<column name="cpu_perf" title="CPU实时简要信息" />
				<sql>
					select  sys_util('cpu_util.sh','cpu_perf') as cpu_perf;
				</sql>
			</cpu_perf>
			<!--获取实时内存信息 -->
			<show_mem>
				<column name="show_mem" title="实时内存信息" />
				<sql>
					select  sys_util('mem_util.sh','show_mem') as show_mem;
				</sql>
			</show_mem>
			<!--实时获取硬盘简要使用信息 -->
			<show_disk_perf>
				<column name="show_disk_perf" title="硬盘简要使用信息" />
				<sql>
					select  sys_util('disk_util.sh','show_disk_perf') as show_disk_perf;
				</sql>
			</show_disk_perf>
			<!-- 2、实时获取硬盘详细使用信息 -->
			<show_disk_usage>
				<column name="show_disk_usage" title="硬盘详细使用信息 " />
				<sql>
					select  sys_util('disk_util.sh','show_disk_usage') as show_disk_usage;
				</sql>
			</show_disk_usage>
			<!--获取进程信息，根据CPU排序 -->
			<show_ps_top_cpu>
				<column name="show_ps_top_cpu" title="进程信息-CPU排序 " />
				<sql>
					select  sys_util('ps_util.sh','show_ps_top_cpu') as show_ps_top_cpu;
				</sql>
			</show_ps_top_cpu>
			<!--获取所有进程信息，根据内存排序 -->
			<show_ps_top_mem>
				<column name="show_ps_top_mem" title="进程信息-内存排序 " />
				<sql>
					select  sys_util('ps_util.sh','show_ps_top_mem') as show_ps_top_mem;
				</sql>
			</show_ps_top_mem>
			<!--关键字查询进程详细信息 -->
			<show_ps_by_grep>
				<column name="show_ps_info" title="关键字查询进程" />
				<sql>
					select  sys_util('ps_util.sh',?) as show_ps_info;
				</sql>
			</show_ps_by_grep>
			<!--获取操作系统信息 -->
			<os_info>
				<column name="os_info" title="操作系统信息" />
				<sql>
					select  sys_util('sys_util.sh','os_info') as os_info;
				</sql>
			</os_info>
			
			<!--获取服务器网络监控信息 -->
			<eth_info>
				<column name="eth_list" title="网络监控信息 " />
				<sql>
					select  sys_util('eth_util.sh','eth_list') as eth_list;
				</sql>
			</eth_info>
			 
			<!--获取复制监控信息 -->
			<show_copy> 
				<column name="pid" title="pid" />
				<column name="usesysid" title="usesysid" />
				<column name="usename" title="usename" />
				<column name="application_name" title="application_name" />
				<column name="client_addr" title="client_addr" />
				<column name="client_hostname" title="client_hostname" />
				<column name="client_port" title="client_port" />
				<column name="backend_start" title="backend_start" />
				<column name="backend_xmin" title="backend_xmin" />
				<column name="state" title="state" />
				<column name="sent_location" title="sent_location" />
				<column name="write_location" title="write_location" />
				<column name="flush_location" title="flush_location" />
				<column name="replay_location" title="replay_location" />
				<column name="sync_priority" title="sync_priority" />
				<column name="sync_state" title="sync_state" />
				<column name="hhxlog" title="hhxlog" />
				<sql>
					select  *,pg_xlog_location_diff(sent_location, replay_location) as hhxlog  from pg_stat_replication
				</sql>
			</show_copy>
				<!--获取备机延迟时间信息 -->
			<show_copyback> 
				<column name="log_delay" title="log_delay" />
				<sql>
					SELECT CASE WHEN pg_last_xlog_receive_location() = pg_last_xlog_replay_location()
					THEN 0
					ELSE EXTRACT (EPOCH FROM now() - pg_last_xact_replay_timestamp())
				    END AS log_delay;
				</sql>
			</show_copyback>
		</dbserver>
		
		<!--模式 -->
		<extend>
			<prop>
				<column title="扩展ID" name="refobjid" />
				<column title="扩展名称" name="extendName" />
				<column title="状态" name="status" />
				<column title="扩展内容" name="desc" /> 
				<sql>
					SELECT refobjid,string_agg(pg_catalog.pg_describe_object(classid, objid, 0),' ;') AS "desc",'' status,'' extendName
					FROM pg_catalog.pg_depend
					WHERE refclassid = 'pg_catalog.pg_extension'::pg_catalog.regclass AND refobjid in (SELECT e.oid
					FROM pg_catalog.pg_extension e
					WHERE e.extname = ?
					ORDER BY 1) AND deptype = 'e'
				    group by refobjid;
				</sql>
			</prop>
			<prop_coll>
				<column name="name" title="extname" />
				<column name="extowner" title="extowner" />
				<column name="extnamespace" title="extnamespace" />
				<column name="extrelocatable" title="extrelocatable" /> 
				<column name="extversion" title="extversion" />
				<column name="extconfig" title="extconfig" />
				<column name="extcondition" title="extcondition" />
				<sql>
				select extname as name,extowner,extnamespace,extrelocatable,extversion,extconfig,extcondition from pg_extension;
				</sql>
			</prop_coll>
			<create>
				<column name="extname" title="extname" />
				<sql>
				create extension ?
				</sql>
			</create>
			<drop>
				<column name="extname" title="extname" />
				<sql>
				drop extension ? cascade
				</sql>
			</drop>
		</extend>
		<!-- 数据库锁查询 -->
		<lockstatus>
			<prop_coll> 
				<column name="pid" title="PID" />
				<column name="datname" title="数据库" />
				<column name="usename" title="用户" />
				<column name="client_addr" title="客户端地址" />
				<column name="locktype" title="锁类型" /> 
				<column name="mode" title="模式" /> 
				<column name="query_start" title="开始时间" />
				<column name="query" title="执行sql" />
				<sql>
					select distinct c.pid,a.locktype,a.mode,c.datname,c.usename,c.client_addr,c.query_start,c.query
					from pg_locks a
					join pg_class b on a.relation = b.oid left join pg_stat_activity c on a.pid=c.pid;
				</sql>
			</prop_coll>
		</lockstatus>
		<authorization>
			<prop_coll> 
			<sql>
				CREATE OR REPLACE FUNCTION public.g_or_v(g_or_v text, own name, target name, objtyp text, exp text[], priv text) RETURNS void AS $BODY$ 
					declare
					  nsp name;
					  rel name;
					  sql text;
					  tmp_nsp name := '';
					begin
					  for nsp,rel in select t2.nspname,t1.relname from pg_class t1,pg_namespace t2 where t1.relkind=objtyp and t1.relnamespace=t2.oid and t1.relowner=(select oid from pg_roles where rolname=own)
					  loop
					    if (tmp_nsp = '' or tmp_nsp &lt;&gt; nsp) and lower(g_or_v)='grant' then
					      -- auto grant schema to target user
					      sql := 'GRANT usage on schema "'||nsp||'" to '||target;
					      execute sql;
					      raise notice '%', sql;
					    end if;
					
					    tmp_nsp := nsp;
					
					    if (exp is not null and nsp||'.'||rel = any (exp)) then
					      raise notice '% excluded % .', g_or_v, nsp||'.'||rel;
					    else
					      if lower(g_or_v) = 'grant' then
					        sql := g_or_v||' '||priv||' on "'||nsp||'"."'||rel||'" to '||target ;
					      elsif lower(g_or_v) = 'revoke' then
					        sql := g_or_v||' '||priv||' on "'||nsp||'"."'||rel||'" from '||target ;
					      else
					        raise notice 'you must enter grant or revoke';
						      end if;
						      raise notice '%', sql;
						      execute sql;
						    end if;
						  end loop;
						end;
						$BODY$ LANGUAGE plhhsql VOLATILE;
				</sql>
				</prop_coll>
		</authorization>
	</sql>
</sqls>